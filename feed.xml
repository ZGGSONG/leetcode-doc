<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
<channel>
  <title>LeetCode刷题记录</title>
  <atom:link href="https://pages.zsong.ml/leetcode-doc/feed.xml" rel="self" type="application/rss+xml" />
  <link>https://pages.zsong.ml/leetcode-doc</link>
  <description>LeetCode刷题记录</description>
   
  <item>
    <title><![CDATA[说明]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/README</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/README</guid>
    <description><![CDATA[<h1 id="说明">说明</h1>
<p>LeetCode刷题记录 using Golang by zggsong</p>
<p>blog <a href="//www.zggsong.cn">www.zggsong.cn</a></p>
<p>wiki <a href="//wiki.zggsong.cn">wiki.zggsong.cn</a></p>
<p>RSS <a href="//pages.zsong.ml/leetcode-doc/feed.xml">pages.zsong.ml/leetcode-doc/feed.xml</a></p>]]></description>
    <pubDate>Wed, 24 Aug 2022 14:46:32 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 移除元素]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/array/0027.remove-element</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/array/0027.remove-element</guid>
    <description><![CDATA[<h2 id="移除元素">移除元素</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/remove-element/">https://leetcode.cn/problems/remove-element/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给你一个数组 nums和一个值 val，你需要 原地 移除所有数值等于val的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<pre class="text"><code>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}</code></pre>
<p>示例 1：</p>
<pre class="text"><code>输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</code></pre>
<h2 id="解题思路">解题思路</h2>
<blockquote>
<p><a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#%E6%80%9D%E8%B7%AF">代码随想录-双指针</a></p>
</blockquote>
<ul>
<li>双指针：首先明白，去除元素本质上就是移动元素。快慢指针方式，快指针寻找就数组元素，慢指针更新新数组，如果快指针指向元素不等于需要去除元素，则将快指针元素赋给慢指针指向元素，慢指针右移，否则快指针右移，慢指针不动，如此往复即可得到满足条件新数组，长度则为慢指针指向元素下标值</li>
</ul>
<blockquote>
<p>执行用时： 4 ms，在所有 Go提交中击败了 100.00% 的用户 内存消耗： 2 MB，在所有 Go 提交中击败了 99.91% 的用户</p>
</blockquote>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">func</span> removeElement(nums []<span class="dt">int</span>, val <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="kw">var</span> slowIndex <span class="dt">int</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">for</span> fastIndex := <span class="dv">0</span>; fastIndex &lt; <span class="bu">len</span>(nums); fastIndex++ {</a>
<a class="sourceLine" id="cb4-4" title="4">        <span class="kw">if</span> nums[fastIndex] != val {</a>
<a class="sourceLine" id="cb4-5" title="5">            nums[slowIndex] = nums[fastIndex]</a>
<a class="sourceLine" id="cb4-6" title="6">            slowIndex++</a>
<a class="sourceLine" id="cb4-7" title="7">        }</a>
<a class="sourceLine" id="cb4-8" title="8">    }</a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="kw">return</span> slowIndex</a>
<a class="sourceLine" id="cb4-10" title="10">}</a></code></pre></div>]]></description>
    <pubDate>Wed, 24 Aug 2022 14:38:28 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[开始]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/_sidebar</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/_sidebar</guid>
    <description><![CDATA[<ul>
<li>开始
<ul>
<li><a href="README.md">说明</a></li>
</ul></li>
<li>数组
<ul>
<li><a href="docs/array/0001.two-sum.md">1. 两数之和 (简单)</a></li>
<li><a href="docs/array/0011.container-with-most-water.md">11. 盛最多水的容器 (中等)</a></li>
<li><a href="docs/array/0015.3sum.md">15. 三数之和 (中等)</a></li>
<li><a href="docs/array/0016.3sum-closest.md">16. 最接近的三数之和 (中等)</a></li>
<li><a href="docs/array/0018.4sum.md">18. 四数之和 (中等)</a></li>
<li><a href="docs/array/0027.remove-element.md">27. 移除元素 (简单)</a></li>
<li><a href="docs/array/0031.next-permutation.md">31. 下一个排列 (中等)</a></li>
<li><a href="docs/array/0034.find-first-and-last-position-of-element-in-sorted-array.md">34. 在排序数组中查找元素的第一个和最后一个位置 (中等)</a></li>
<li><a href="docs/array/0069.sqrtx.md">69. x的平方根 (简单)</a></li>
<li><a href="docs/array/0088.merge-sorted-array.md">88. 合并两个有序数组 (简单)</a></li>
<li><a href="docs/array/0118.pascals-triangle.md">118. 杨辉三角 (简单)</a></li>
<li><a href="docs/array/0119.pascals-triangle-ii.md">119. 杨辉三角 II (简单)</a></li>
<li><a href="docs/array/0121.best-time-to-buy-and-sell-stock.md">121. 买卖股票的最佳时机 (简单)</a></li>
<li><a href="docs/array/0136.single-number.md">136. 只出现一次的数字 (简单)</a></li>
<li><a href="docs/array/704.binary-search.md">704. 二分查找 (简单)</a></li>
<li><a href="docs/array/1403.minimum-subsequence-in-non-increasing-order.md">1403. 非递增顺序的最小子序列 (简单)</a></li>
</ul></li>
<li>字符串
<ul>
<li><a href="docs/string/1408.string-matching-in-an-array.md">1408. 数组中的字符串匹配 (简单)</a></li>
<li><a href="docs/string/1417.reformat-the-string.md">1417. 重新格式化字符串 (简单)</a></li>
</ul></li>
<li>链表
<ul>
<li><a href="docs/linkedList/0002.add-two-numbers.md">2. 两数相加 (中等)</a></li>
</ul></li>
</ul>]]></description>
    <pubDate>Wed, 24 Aug 2022 14:38:28 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ x的平方根]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/array/0069.sqrtx</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/array/0069.sqrtx</guid>
    <description><![CDATA[<h2 id="x的平方根">x的平方根</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/sqrtx/">https://leetcode.cn/problems/sqrtx/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给你一个非负整数 x ，计算并返回x的 算术平方根 。</p>
<p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p>
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：x = 4
输出：2</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。</code></pre>
<h2 id="解题思路">解题思路</h2>
<blockquote>
<p><a href="https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/10628618#%E7%AE%97%E6%B3%95%E8%A6%81%E6%B1%82">二分查找条件</a>：顺序存储结构、关键字按大小顺序排列</p>
</blockquote>
<ul>
<li>二分查找，整数的的算术平方根必然在[0,x]之间，除1外，当两者相差大于1才能往中间去值计算平方才能与x进行比较，否则返回左边的值(小数取整)，在循环内部则可以理解成左右均为<a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF">开区间</a>，不满足条件则分别将mid赋值给left或者right，如果正好有算术平方根则返回 &gt; 执行用时： 0 ms，在所有 Go 提交中击败了 100.00% 的用户 内存消耗： 2 MB，在所有 Go 提交中击败了 60.52% 的用户</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">func</span> mySqrt(x <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="kw">if</span> x == <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb3-3" title="3">        <span class="kw">return</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-4" title="4">    }</a>
<a class="sourceLine" id="cb3-5" title="5">    left, right := <span class="dv">0</span>, x</a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="kw">for</span> right-left &gt; <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb3-7" title="7">        mid := left + (right-left)/<span class="dv">2</span></a>
<a class="sourceLine" id="cb3-8" title="8">        <span class="kw">if</span> mid*mid &gt; x {</a>
<a class="sourceLine" id="cb3-9" title="9">            right = mid</a>
<a class="sourceLine" id="cb3-10" title="10">        } <span class="kw">else</span> <span class="kw">if</span> mid*mid &lt; x {</a>
<a class="sourceLine" id="cb3-11" title="11">            left = mid</a>
<a class="sourceLine" id="cb3-12" title="12">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb3-13" title="13">            <span class="kw">return</span> mid</a>
<a class="sourceLine" id="cb3-14" title="14">        }</a>
<a class="sourceLine" id="cb3-15" title="15">    }</a>
<a class="sourceLine" id="cb3-16" title="16">    <span class="kw">return</span> left</a>
<a class="sourceLine" id="cb3-17" title="17">}</a></code></pre></div>
<ul>
<li>二分查找，典型的<a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF">左闭右开</a>，条件<code>l&lt;r</code> &gt; 执行用时： 0 ms，在所有 Go 提交中击败了 100.00% 的用户 内存消耗： 2 MB，在所有 Go 提交中击败了 60.52% 的用户</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">func</span> mySqrt(x <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb4-2" title="2">    l, r := <span class="dv">0</span>, x</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">for</span> l &lt; r {</a>
<a class="sourceLine" id="cb4-4" title="4">        mid := (l + r + <span class="dv">1</span>) / <span class="dv">2</span></a>
<a class="sourceLine" id="cb4-5" title="5">        <span class="kw">if</span> mid*mid &gt; x {</a>
<a class="sourceLine" id="cb4-6" title="6">            r = mid - <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-7" title="7">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb4-8" title="8">            l = mid</a>
<a class="sourceLine" id="cb4-9" title="9">        }</a>
<a class="sourceLine" id="cb4-10" title="10">    }</a>
<a class="sourceLine" id="cb4-11" title="11">    <span class="kw">return</span> l</a>
<a class="sourceLine" id="cb4-12" title="12">}</a></code></pre></div>
<ul>
<li>牛顿迭代法, <a href="https://en.wikipedia.org/wiki/Integer_square_root">https://en.wikipedia.org/wiki/Integer_square_root</a>，求根号 x，即求满足 x^2 - n = 0 方程的所有解。 &gt; 执行用时： 4 ms，在所有 Go 提交中击败了 43.85% 的用户 内存消耗： 2 MB，在所有 Go 提交中击败了 99.83% 的用户</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">func</span> mySqrt(x <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb5-2" title="2">    r := x</a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="kw">for</span> r*r &gt; x {</a>
<a class="sourceLine" id="cb5-4" title="4">        r = (r + x/r) / <span class="dv">2</span></a>
<a class="sourceLine" id="cb5-5" title="5">    }</a>
<a class="sourceLine" id="cb5-6" title="6">    <span class="kw">return</span> r</a>
<a class="sourceLine" id="cb5-7" title="7">}</a></code></pre></div>]]></description>
    <pubDate>Wed, 24 Aug 2022 11:38:38 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 在排序数组中查找元素的第一个和最后一个位置]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/array/0034.find-first-and-last-position-of-element-in-sorted-array</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/array/0034.find-first-and-last-position-of-element-in-sorted-array</guid>
    <description><![CDATA[<h2 id="在排序数组中查找元素的第一个和最后一个位置">在排序数组中查找元素的第一个和最后一个位置</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回[-1, -1]。</p>
<p>你必须设计并实现时间复杂度为O(log n)的算法解决此问题。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]</code></pre>
<p>示例 3：</p>
<pre><code>输入：nums = [], target = 0
输出：[-1,-1]</code></pre>
<h2 id="解题思路">解题思路</h2>
<ul>
<li>分为三种情况：1. 数组范围外，2. 数组范围内且存在，3. 数组范围内且不存在。先判断是否在数组外，如果在随后使用二分法，根据题意使用左闭右闭的方式(即<code>left&lt;=right</code>)，在mid==target的条件下往左查找开始位置，往右查找结束位置，注意数组边界；如果始终不满足mid==target条件，则返回[-1,-1] &gt; 执行用时： 4 ms，在所有Go提交中击败了 96.19% 的用户 内存消耗： 3.8 MB， 在所有 Go 提交中击败了 57.76% 的用户</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">func</span> searchRange(nums []<span class="dt">int</span>, target <span class="dt">int</span>) []<span class="dt">int</span> {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="co">//1. 在数组外</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">if</span> <span class="bu">len</span>(nums) == <span class="dv">0</span> || nums[<span class="dv">0</span>] &gt; target || nums[<span class="bu">len</span>(nums)-<span class="dv">1</span>] &lt; target {</a>
<a class="sourceLine" id="cb4-4" title="4">        <span class="kw">return</span> []<span class="dt">int</span>{-<span class="dv">1</span>, <span class="dv">-1</span>}</a>
<a class="sourceLine" id="cb4-5" title="5">    }</a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="co">//2. 在数组内</span></a>
<a class="sourceLine" id="cb4-7" title="7">    left, right := <span class="dv">0</span>, <span class="bu">len</span>(nums)-<span class="dv">1</span></a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="kw">var</span> ret []<span class="dt">int</span></a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="kw">for</span> left &lt;= right {</a>
<a class="sourceLine" id="cb4-10" title="10">        mid := left + (right-left)/<span class="dv">2</span></a>
<a class="sourceLine" id="cb4-11" title="11">        <span class="kw">if</span> nums[mid] &lt; target {</a>
<a class="sourceLine" id="cb4-12" title="12">            left = mid + <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-13" title="13">        } <span class="kw">else</span> <span class="kw">if</span> nums[mid] &gt; target {</a>
<a class="sourceLine" id="cb4-14" title="14">            right = mid - <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-15" title="15">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb4-16" title="16">            <span class="co">//2.1 在数组范围内且存在</span></a>
<a class="sourceLine" id="cb4-17" title="17">            mid2 := mid</a>
<a class="sourceLine" id="cb4-18" title="18">            <span class="kw">for</span> mid<span class="dv">-1</span> &gt;= <span class="dv">0</span> &amp;&amp; nums[mid<span class="dv">-1</span>] == target {</a>
<a class="sourceLine" id="cb4-19" title="19">                mid--</a>
<a class="sourceLine" id="cb4-20" title="20">            }</a>
<a class="sourceLine" id="cb4-21" title="21">            ret = <span class="bu">append</span>(ret, mid)</a>
<a class="sourceLine" id="cb4-22" title="22">            <span class="kw">for</span> mid2+<span class="dv">1</span> &lt;= <span class="bu">len</span>(nums)-<span class="dv">1</span> &amp;&amp; nums[mid2+<span class="dv">1</span>] == target {</a>
<a class="sourceLine" id="cb4-23" title="23">                mid2++</a>
<a class="sourceLine" id="cb4-24" title="24">            }</a>
<a class="sourceLine" id="cb4-25" title="25">            ret = <span class="bu">append</span>(ret, mid2)</a>
<a class="sourceLine" id="cb4-26" title="26">            <span class="kw">return</span> ret</a>
<a class="sourceLine" id="cb4-27" title="27">        }</a>
<a class="sourceLine" id="cb4-28" title="28">    }</a>
<a class="sourceLine" id="cb4-29" title="29">    <span class="co">//2.2 在数组范围内且不存在</span></a>
<a class="sourceLine" id="cb4-30" title="30">    <span class="kw">return</span> []<span class="dt">int</span>{-<span class="dv">1</span>, <span class="dv">-1</span>}</a>
<a class="sourceLine" id="cb4-31" title="31">}</a></code></pre></div>
<ul>
<li>来自<a href="https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0034.Find-First-and-Last-Position-of-Element-in-Sorted-Array/">LeetCodeCookBook</a> 也是从三种情况入手，不过处理方式是分别处理开始位置和结束位置</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">func</span> searchRange(nums []<span class="dt">int</span>, target <span class="dt">int</span>) []<span class="dt">int</span> {</a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="kw">return</span> []<span class="dt">int</span>{searchFirstEqualElement(nums, target), searchLastEqualElement(nums, target)}</a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4">}</a>
<a class="sourceLine" id="cb5-5" title="5"></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="co">// 二分查找第一个与 target 相等的元素，时间复杂度 O(logn)</span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="kw">func</span> searchFirstEqualElement(nums []<span class="dt">int</span>, target <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb5-8" title="8">    low, high := <span class="dv">0</span>, <span class="bu">len</span>(nums)-<span class="dv">1</span></a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="kw">for</span> low &lt;= high {</a>
<a class="sourceLine" id="cb5-10" title="10">        mid := low + ((high - low) &gt;&gt; <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb5-11" title="11">        <span class="kw">if</span> nums[mid] &gt; target {</a>
<a class="sourceLine" id="cb5-12" title="12">            high = mid - <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-13" title="13">        } <span class="kw">else</span> <span class="kw">if</span> nums[mid] &lt; target {</a>
<a class="sourceLine" id="cb5-14" title="14">            low = mid + <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-15" title="15">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb5-16" title="16">            <span class="kw">if</span> (mid == <span class="dv">0</span>) || (nums[mid<span class="dv">-1</span>] != target) { <span class="co">// 找到第一个与 target 相等的元素</span></a>
<a class="sourceLine" id="cb5-17" title="17">                <span class="kw">return</span> mid</a>
<a class="sourceLine" id="cb5-18" title="18">            }</a>
<a class="sourceLine" id="cb5-19" title="19">            high = mid - <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-20" title="20">        }</a>
<a class="sourceLine" id="cb5-21" title="21">    }</a>
<a class="sourceLine" id="cb5-22" title="22">    <span class="kw">return</span> <span class="dv">-1</span></a>
<a class="sourceLine" id="cb5-23" title="23">}</a>
<a class="sourceLine" id="cb5-24" title="24"></a>
<a class="sourceLine" id="cb5-25" title="25"><span class="co">// 二分查找最后一个与 target 相等的元素，时间复杂度 O(logn)</span></a>
<a class="sourceLine" id="cb5-26" title="26"><span class="kw">func</span> searchLastEqualElement(nums []<span class="dt">int</span>, target <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb5-27" title="27">    low, high := <span class="dv">0</span>, <span class="bu">len</span>(nums)-<span class="dv">1</span></a>
<a class="sourceLine" id="cb5-28" title="28">    <span class="kw">for</span> low &lt;= high {</a>
<a class="sourceLine" id="cb5-29" title="29">        mid := low + ((high - low) &gt;&gt; <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb5-30" title="30">        <span class="kw">if</span> nums[mid] &gt; target {</a>
<a class="sourceLine" id="cb5-31" title="31">            high = mid - <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-32" title="32">        } <span class="kw">else</span> <span class="kw">if</span> nums[mid] &lt; target {</a>
<a class="sourceLine" id="cb5-33" title="33">            low = mid + <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-34" title="34">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb5-35" title="35">            <span class="kw">if</span> (mid == <span class="bu">len</span>(nums)-<span class="dv">1</span>) || (nums[mid+<span class="dv">1</span>] != target) { <span class="co">// 找到最后一个与 target 相等的元素</span></a>
<a class="sourceLine" id="cb5-36" title="36">                <span class="kw">return</span> mid</a>
<a class="sourceLine" id="cb5-37" title="37">            }</a>
<a class="sourceLine" id="cb5-38" title="38">            low = mid + <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-39" title="39">        }</a>
<a class="sourceLine" id="cb5-40" title="40">    }</a>
<a class="sourceLine" id="cb5-41" title="41">    <span class="kw">return</span> <span class="dv">-1</span></a>
<a class="sourceLine" id="cb5-42" title="42">}</a></code></pre></div>]]></description>
    <pubDate>Tue, 23 Aug 2022 19:52:22 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 重新格式化字符串]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/string/1417.reformat-the-string</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/string/1417.reformat-the-string</guid>
    <description><![CDATA[<h2 id="重新格式化字符串">重新格式化字符串</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/reformat-the-string/">https://leetcode.cn/problems/reformat-the-string/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。</p>
<p>请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。</p>
<p>请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：s = &quot;a0b1c2&quot;
输出：&quot;0a1b2c&quot;
解释：&quot;0a1b2c&quot; 中任意两个相邻字符的类型都不同。 &quot;a0b1c2&quot;, &quot;0a1b2c&quot;, &quot;0c2a1b&quot; 也是满足题目要求的答案。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：s = &quot;leetcode&quot;
输出：&quot;&quot;
解释：&quot;leetcode&quot; 中只有字母，所以无法满足重新格式化的条件。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：s = &quot;leetcode&quot;
输出：&quot;&quot;
解释：&quot;leetcode&quot; 中只有字母，所以无法满足重新格式化的条件。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：s = &quot;leetcode&quot;
输出：&quot;&quot;
解释：&quot;leetcode&quot; 中只有字母，所以无法满足重新格式化的条件。</code></pre>
<p>示例 3：</p>
<pre class="text"><code>输入：s = &quot;1229857369&quot;
输出：&quot;&quot;
解释：&quot;1229857369&quot; 中只有数字，所以无法满足重新格式化的条件。</code></pre>
<p>示例 4：</p>
<pre class="text"><code>输入：s = &quot;covid2019&quot;
输出：&quot;c2o0v1i9d&quot;输入：s = &quot;covid2019&quot;
输出：&quot;c2o0v1i9d&quot;</code></pre>
<p>示例5：</p>
<pre class="text"><code>输入：s = &quot;ab123&quot;
输出：&quot;1a2b3&quot;</code></pre>
<h2 id="解题思路">解题思路</h2>
<ul>
<li>数组暴力解法：分割成两个数组，字符数组，数字数组，然后去除不满足的情况（两个数组长度之差超过1的则为不满足）随后判断谁大，那个先添加到字符串中，直至添加完成 &gt; 执行用时： 4 ms，在所有Go提交中击败了 22.86％ 的用户 内存消耗： 6.6 MB，在所有 Go 提交中击败了 17.14% 的用户</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">func</span> reformat(s <span class="dt">string</span>) <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb8-2" title="2">    ret, c1, c2 := <span class="st">&quot;&quot;</span>, []<span class="dt">string</span>{}, []<span class="dt">string</span>{}</a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="kw">for</span> _, v := <span class="kw">range</span> s {</a>
<a class="sourceLine" id="cb8-4" title="4">        <span class="kw">if</span> v &gt;= <span class="dv">48</span> &amp;&amp; v &lt;= <span class="dv">57</span> {</a>
<a class="sourceLine" id="cb8-5" title="5">            c1 = <span class="bu">append</span>(c1, <span class="dt">string</span>(v))</a>
<a class="sourceLine" id="cb8-6" title="6">            <span class="kw">continue</span></a>
<a class="sourceLine" id="cb8-7" title="7">        }</a>
<a class="sourceLine" id="cb8-8" title="8">        c2 = <span class="bu">append</span>(c2, <span class="dt">string</span>(v))</a>
<a class="sourceLine" id="cb8-9" title="9">    }</a>
<a class="sourceLine" id="cb8-10" title="10">    sub := <span class="bu">len</span>(c1) - <span class="bu">len</span>(c2)</a>
<a class="sourceLine" id="cb8-11" title="11">    <span class="kw">if</span> sub &lt;= <span class="dv">1</span> &amp;&amp; sub &gt;= <span class="dv">-1</span> {</a>
<a class="sourceLine" id="cb8-12" title="12">        <span class="kw">if</span> sub &lt; <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb8-13" title="13">            c1, c2 = c2, c1</a>
<a class="sourceLine" id="cb8-14" title="14">        }</a>
<a class="sourceLine" id="cb8-15" title="15">        <span class="kw">for</span> i := <span class="kw">range</span> c2 {</a>
<a class="sourceLine" id="cb8-16" title="16">            ret += c1[i] + c2[i]</a>
<a class="sourceLine" id="cb8-17" title="17">        }</a>
<a class="sourceLine" id="cb8-18" title="18">        <span class="kw">if</span> sub != <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb8-19" title="19">            ret += c1[<span class="bu">len</span>(c1)-<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb8-20" title="20">        }</a>
<a class="sourceLine" id="cb8-21" title="21">    }</a>
<a class="sourceLine" id="cb8-22" title="22">    <span class="kw">return</span> ret</a>
<a class="sourceLine" id="cb8-23" title="23">}</a></code></pre></div>
<ul>
<li>字符串暴力解法：方法同数组解法 &gt; 执行用时：8ms，在所有 Go 提交中击败了 14.29% 的用户 内存消耗：6.7 MB，在所有Go提交中击败了 11.43% 的用户</li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">func</span> reformat(s <span class="dt">string</span>) <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb9-2" title="2">    s1, s2 := <span class="st">&quot;&quot;</span>, <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="kw">for</span> _, v := <span class="kw">range</span> s {</a>
<a class="sourceLine" id="cb9-4" title="4">        <span class="kw">if</span> v &gt;= <span class="dv">48</span> &amp;&amp; v &lt;= <span class="dv">57</span> {</a>
<a class="sourceLine" id="cb9-5" title="5">            s1 += <span class="dt">string</span>(v)</a>
<a class="sourceLine" id="cb9-6" title="6">            <span class="kw">continue</span></a>
<a class="sourceLine" id="cb9-7" title="7">        }</a>
<a class="sourceLine" id="cb9-8" title="8">        s2 += <span class="dt">string</span>(v)</a>
<a class="sourceLine" id="cb9-9" title="9">    }</a>
<a class="sourceLine" id="cb9-10" title="10">    <span class="kw">if</span> <span class="bu">len</span>(s1)-<span class="bu">len</span>(s2) &lt;= <span class="dv">1</span> &amp;&amp; <span class="bu">len</span>(s1)-<span class="bu">len</span>(s2) &gt;= <span class="dv">-1</span> {</a>
<a class="sourceLine" id="cb9-11" title="11">        <span class="kw">if</span> <span class="bu">len</span>(s1) &lt; <span class="bu">len</span>(s2) {</a>
<a class="sourceLine" id="cb9-12" title="12">            s1, s2 = s2, s1</a>
<a class="sourceLine" id="cb9-13" title="13">        }</a>
<a class="sourceLine" id="cb9-14" title="14">        ret := <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb9-15" title="15">        <span class="kw">for</span> i, _ := <span class="kw">range</span> s2 {</a>
<a class="sourceLine" id="cb9-16" title="16">            ret += <span class="dt">string</span>(s1[i]) + <span class="dt">string</span>(s2[i])</a>
<a class="sourceLine" id="cb9-17" title="17">        }</a>
<a class="sourceLine" id="cb9-18" title="18">        <span class="kw">if</span> <span class="bu">len</span>(s1) != <span class="bu">len</span>(s2) {</a>
<a class="sourceLine" id="cb9-19" title="19">            ret += <span class="dt">string</span>(s1[<span class="bu">len</span>(s1)-<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb9-20" title="20">        }</a>
<a class="sourceLine" id="cb9-21" title="21">        <span class="kw">return</span> ret</a>
<a class="sourceLine" id="cb9-22" title="22">    }</a>
<a class="sourceLine" id="cb9-23" title="23">    <span class="kw">return</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb9-24" title="24">}</a></code></pre></div>]]></description>
    <pubDate>Wed, 17 Aug 2022 17:09:26 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 数组中的字符串匹配]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/string/1408.string-matching-in-an-array</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/string/1408.string-matching-in-an-array</guid>
    <description><![CDATA[<h2 id="数组中的字符串匹配">数组中的字符串匹配</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/string-matching-in-an-array/">https://leetcode.cn/problems/string-matching-in-an-array/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。</p>
<p>如果你可以删除 words[j]最左侧和/或最右侧的若干字符得到 word[i] ，那么字符串 words[i] 就是 words[j] 的一个子字符串。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：words = [&quot;mass&quot;,&quot;as&quot;,&quot;hero&quot;,&quot;superhero&quot;]
输出：[&quot;as&quot;,&quot;hero&quot;]
解释：&quot;as&quot; 是 &quot;mass&quot; 的子字符串，&quot;hero&quot; 是 &quot;superhero&quot; 的子字符串。
[&quot;hero&quot;,&quot;as&quot;] 也是有效的答案。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：words = [&quot;leetcode&quot;,&quot;et&quot;,&quot;code&quot;]
输出：[&quot;et&quot;,&quot;code&quot;]
解释：&quot;et&quot; 和 &quot;code&quot; 都是 &quot;leetcode&quot; 的子字符串。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：words = [&quot;leetcode&quot;,&quot;et&quot;,&quot;code&quot;]
输出：[&quot;et&quot;,&quot;code&quot;]
解释：&quot;et&quot; 和 &quot;code&quot; 都是 &quot;leetcode&quot; 的子字符串。</code></pre>
<p>示例 3：</p>
<pre class="text"><code>输入：words = [&quot;blue&quot;,&quot;green&quot;,&quot;bu&quot;]
输出：[]</code></pre>
<h2 id="解题思路">解题思路</h2>
<ol type="1">
<li>(self) 暴力解法，如果有包含的则直接添加 –内存消耗：2.2 MB, 在所有 Go 提交中击败了51.61%的用户</li>
</ol>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">var</span> ret []<span class="dt">string</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">for</span> k1, v1 := <span class="kw">range</span> words {</a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="kw">for</span> k2, v2 := <span class="kw">range</span> words {</a>
<a class="sourceLine" id="cb5-4" title="4">        <span class="kw">if</span> k1 != k2 &amp;&amp; strings.Contains(v2, v1) {</a>
<a class="sourceLine" id="cb5-5" title="5">            ret = <span class="bu">append</span>(ret, v1)</a>
<a class="sourceLine" id="cb5-6" title="6">            <span class="kw">break</span></a>
<a class="sourceLine" id="cb5-7" title="7">        }</a>
<a class="sourceLine" id="cb5-8" title="8">    }</a>
<a class="sourceLine" id="cb5-9" title="9">}</a>
<a class="sourceLine" id="cb5-10" title="10"><span class="kw">return</span> ret</a></code></pre></div>
<ol start="2" type="1">
<li>(other) 未想到更好的做法，提示–&gt; 研究下KMP算法在这题的应用</li>
</ol>]]></description>
    <pubDate>Wed, 17 Aug 2022 17:09:26 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 杨辉三角II]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/array/0119.pascals-triangle-ii</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/array/0119.pascals-triangle-ii</guid>
    <description><![CDATA[<h2 id="杨辉三角ii">杨辉三角II</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/pascals-triangle-ii/">https://leetcode.cn/problems/pascals-triangle-ii/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。<br />
在「杨辉三角」中，每个数是它左上方和右上方的数的和。 <img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="杨辉三角" /></p>
<p>示例 1：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1">输入: <span class="ex">rowIndex</span> = 3</a>
<a class="sourceLine" id="cb1-2" title="2">输出: [<span class="ex">1</span>,3,3,1]</a></code></pre></div>
<p>示例 2：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1">输入: <span class="ex">rowIndex</span> = 0</a>
<a class="sourceLine" id="cb2-2" title="2">输出: [<span class="ex">1</span>]</a></code></pre></div>
<p>示例 3：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1">输入: <span class="ex">rowIndex</span> = 1</a>
<a class="sourceLine" id="cb3-2" title="2">输出: [<span class="ex">1</span>,1]</a></code></pre></div>
<h2 id="解题思路">解题思路</h2>
<ol type="1">
<li>(self) 偷懒做法，直接利用上一题的结果取最后一行，必然会造成内存浪费，但不失为一种方法</li>
</ol>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1">ret := <span class="bu">make</span>([][]<span class="dt">int</span>, numRows)</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">for</span> i := <span class="dv">0</span>; i &lt; numRows; i++ {</a>
<a class="sourceLine" id="cb4-3" title="3">    ret[i] = <span class="bu">make</span>([]<span class="dt">int</span>, i+<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="kw">for</span> j := <span class="dv">0</span>; j &lt;= i; j++ {</a>
<a class="sourceLine" id="cb4-5" title="5">        <span class="kw">if</span> i == j || j &lt; <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb4-6" title="6">        ret[i][j] = <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-7" title="7">        <span class="kw">continue</span></a>
<a class="sourceLine" id="cb4-8" title="8">    }</a>
<a class="sourceLine" id="cb4-9" title="9">    ret[i][j] = ret[i<span class="dv">-1</span>][j] + ret[i<span class="dv">-1</span>][j<span class="dv">-1</span>]</a>
<a class="sourceLine" id="cb4-10" title="10">    }</a>
<a class="sourceLine" id="cb4-11" title="11">}</a>
<a class="sourceLine" id="cb4-12" title="12"><span class="kw">return</span> ret</a></code></pre></div>
<ol start="2" type="1">
<li><a href="https://books.halfrost.com/leetcode/ChapterFour/0100~0199/0119.Pascals-Triangle-II/">(other)</a>-<a href="https://zhuanlan.zhihu.com/p/257895125">解释杨辉三角排列组合</a><br />
<strong>根据杨辉三角的数学特性得出的公式直接计算，递推公式为：<code>ret[i] = ret[i-1] * (rowIndex - i + 1) / i</code></strong></li>
</ol>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb5-1" title="1">ret := <span class="bu">make</span>([]<span class="dt">int</span>, rowIndex+<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb5-2" title="2">ret[<span class="dv">0</span>] = <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">for</span> i := <span class="dv">1</span>; i &lt;= rowIndex; i++ {</a>
<a class="sourceLine" id="cb5-4" title="4">    ret[i] = ret[i<span class="dv">-1</span>] * (rowIndex - i + <span class="dv">1</span>) / i</a>
<a class="sourceLine" id="cb5-5" title="5">}</a>
<a class="sourceLine" id="cb5-6" title="6"><span class="kw">return</span> ret</a></code></pre></div>]]></description>
    <pubDate>Wed, 17 Aug 2022 17:09:26 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 两数相加]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/linkedList/0002.add-two-numbers</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/linkedList/0002.add-two-numbers</guid>
    <description><![CDATA[<h2 id="两数相加">两数相加</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/add-two-numbers/">https://leetcode.cn/problems/add-two-numbers/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给你两个非空 的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0开头。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：l1 = [0], l2 = [0]
输出：[0]</code></pre>
<p>示例 3：</p>
<pre class="text"><code>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]</code></pre>
<p>每个链表中的节点数在范围 [1, 100] 内 0 &lt;= Node.val &lt;= 9 题目数据保证列表表示的数字不含前导零</p>
<h2 id="解题思路">解题思路</h2>
<p>O(n) 直接按照链表格式，先定义一个头节点，暂存值为0，每个链表取一个节点出来将Value与暂存值累加，然后取余数保存到自己定义链表的下一个节点的Value，取10的商保存为暂存值，随后将当前节点作为源节点的子节点，如此循环往复，直到两个链表为空和暂存值都为零时，则说明计算完成，返回头节点的下一个节点即可得到所求链表</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1">list := &amp;ListNode{<span class="dv">0</span>, <span class="ot">nil</span>}</a>
<a class="sourceLine" id="cb4-2" title="2">ret := list</a>
<a class="sourceLine" id="cb4-3" title="3">tmp := <span class="dv">0</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="kw">for</span> l1 != <span class="ot">nil</span> || l2 != <span class="ot">nil</span> || tmp != <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="kw">if</span> l1 != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb4-6" title="6">        tmp += l1.Val</a>
<a class="sourceLine" id="cb4-7" title="7">        l1 = l1.Next</a>
<a class="sourceLine" id="cb4-8" title="8">    }</a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="kw">if</span> l2 != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb4-10" title="10">        tmp += l2.Val</a>
<a class="sourceLine" id="cb4-11" title="11">        l2 = l2.Next</a>
<a class="sourceLine" id="cb4-12" title="12">    }</a>
<a class="sourceLine" id="cb4-13" title="13">    list.Next = &amp;ListNode{tmp % <span class="dv">10</span>, <span class="ot">nil</span>}</a>
<a class="sourceLine" id="cb4-14" title="14">    tmp = tmp / <span class="dv">10</span></a>
<a class="sourceLine" id="cb4-15" title="15">    list = list.Next</a>
<a class="sourceLine" id="cb4-16" title="16">}</a>
<a class="sourceLine" id="cb4-17" title="17"><span class="kw">return</span> ret.Next</a></code></pre></div>]]></description>
    <pubDate>Wed, 17 Aug 2022 17:00:10 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 二分查找]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/array/704.binary-search</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/array/704.binary-search</guid>
    <description><![CDATA[<h2 id="二分查找">二分查找</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给定一个n个元素有序的（升序）整型数组nums 和一个目标值target ，写一个函数搜索nums中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>示例 1：</p>
<pre class="text"><code>输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1</code></pre>
<p>提示：</p>
<ul>
<li>你可以假设 nums 中的所有元素是不重复的。</li>
<li>n 将在 [1, 10000]之间。</li>
<li>nums 的每个元素都将在 [-9999, 9999]之间。</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<ul>
<li><p>二分法主要关注循环条件，以及循环里判断后，针对中间值的处理过程，闭区间与开区间需要区分</p></li>
<li>左闭右闭</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">func</span> search(nums []<span class="dt">int</span>, target <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb3-2" title="2">    begin, end, mid := <span class="dv">0</span>, <span class="bu">len</span>(nums)-<span class="dv">1</span>, (<span class="bu">len</span>(nums)-<span class="dv">1</span>)/<span class="dv">2</span></a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="co">//左闭右闭</span></a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="kw">for</span> begin &lt;= end {</a>
<a class="sourceLine" id="cb3-5" title="5">        <span class="kw">if</span> target &lt; nums[mid] {</a>
<a class="sourceLine" id="cb3-6" title="6">            end = mid - <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-7" title="7">        } <span class="kw">else</span> <span class="kw">if</span> target &gt; nums[mid] {</a>
<a class="sourceLine" id="cb3-8" title="8">            begin = mid + <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-9" title="9">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb3-10" title="10">            <span class="kw">return</span> mid</a>
<a class="sourceLine" id="cb3-11" title="11">        }</a>
<a class="sourceLine" id="cb3-12" title="12">        mid = (begin + end) / <span class="dv">2</span></a>
<a class="sourceLine" id="cb3-13" title="13">        <span class="co">//begin和end为int，避免越界可以写成</span></a>
<a class="sourceLine" id="cb3-14" title="14">        <span class="co">//mid = begin + (end - begin) / 2</span></a>
<a class="sourceLine" id="cb3-15" title="15">    }</a>
<a class="sourceLine" id="cb3-16" title="16">    <span class="kw">return</span> <span class="dv">-1</span></a>
<a class="sourceLine" id="cb3-17" title="17">}</a></code></pre></div>
<ul>
<li>左闭右开</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">func</span> search(nums []<span class="dt">int</span>, target <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb4-2" title="2">    left, right := <span class="dv">0</span>, <span class="bu">len</span>(nums)-<span class="dv">1</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">for</span> left &lt; right {</a>
<a class="sourceLine" id="cb4-4" title="4">        mid := left + (right-left)/<span class="dv">2</span></a>
<a class="sourceLine" id="cb4-5" title="5">        <span class="kw">if</span> nums[mid] &gt; target {</a>
<a class="sourceLine" id="cb4-6" title="6">            right = mid</a>
<a class="sourceLine" id="cb4-7" title="7">        } <span class="kw">else</span> <span class="kw">if</span> nums[mid] &lt; target {</a>
<a class="sourceLine" id="cb4-8" title="8">            left = mid + <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-9" title="9">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb4-10" title="10">            <span class="kw">return</span> mid</a>
<a class="sourceLine" id="cb4-11" title="11">        }</a>
<a class="sourceLine" id="cb4-12" title="12">    }</a>
<a class="sourceLine" id="cb4-13" title="13">    <span class="kw">return</span> <span class="dv">-1</span></a>
<a class="sourceLine" id="cb4-14" title="14">}</a></code></pre></div>]]></description>
    <pubDate>Wed, 17 Aug 2022 17:00:10 +0800</pubDate>
  </item>
  
</channel>
</rss>
