<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
<channel>
  <title>LeetCode刷题记录</title>
  <atom:link href="https://pages.zsong.ml/leetcode-doc/feed.xml" rel="self" type="application/rss+xml" />
  <link>https://pages.zsong.ml/leetcode-doc</link>
  <description>LeetCode刷题记录</description>
   
  <item>
    <title><![CDATA[ 双指针法]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/methods/double-pointer</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/methods/double-pointer</guid>
    <description><![CDATA[<h2 id="双指针法">双指针法</h2>
<p>顾名思义，双指针即用两个不同速度或不同方向的指针对数组或对象进行访问，通过两个不同指针的碰撞从而达到特定的目的。</p>
<p><a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95">Carl随想录链接</a></p>
<h2 id="用途">用途</h2>
<p>在时间或空间条件有限的情况下使用单向遍历需要消耗大量的时间或者根本无法解决问题，这时候就需要我们使用双指针，通过指针的碰撞判断是否达到条件，从而解决问题。</p>
<p>双指针分为快慢指针和左右指针，左右指针通常在数组有序的情况下使用，快慢指针通常在单向遍历需要消耗大量时间，或者有特定要求限制的情况下使用。</p>
<h2 id="题目">题目</h2>
<p><a href="docs/array/0026.remove-duplicates-from-sorted-array.md">26. 删除有序数组中的重复项 (简单)</a><br />
<a href="docs/array/0027.remove-element.md">27. 移除元素 (简单)</a><br />
<a href="docs/array/0283.move-zeroes.md">283. 移动零 (简单)</a></p>]]></description>
    <pubDate>Thu, 25 Aug 2022 17:05:27 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 二分查找]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/methods/binary-search</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/methods/binary-search</guid>
    <description><![CDATA[<h2 id="二分查找">二分查找</h2>
<p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。 首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p>
<p><a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E4%BA%8C%E5%88%86%E6%B3%95%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95">Carl随想录链接</a></p>
<h2 id="题目">题目</h2>
<p><a href="docs/array/0034.find-first-and-last-position-of-element-in-sorted-array.md">34. 在排序数组中查找元素的第一个和最后一个位置 (中等)</a><br />
<a href="docs/array/0069.sqrtx.md">69. x的平方根 (简单)</a><br />
<a href="docs/array/704.binary-search.md">704. 二分查找 (简单)</a></p>]]></description>
    <pubDate>Thu, 25 Aug 2022 17:05:27 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[开始]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/_sidebar</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/_sidebar</guid>
    <description><![CDATA[<ul>
<li>开始
<ul>
<li><a href="README.md">说明</a></li>
</ul></li>
<li>方法
<ul>
<li><a href="docs/methods/binary-search.md">二分查找</a></li>
<li><a href="docs/methods/double-pointer.md">双指针法</a></li>
</ul></li>
<li>数组
<ul>
<li><a href="docs/array/0001.two-sum.md">1. 两数之和 (简单)</a></li>
<li><a href="docs/array/0011.container-with-most-water.md">11. 盛最多水的容器 (中等)</a></li>
<li><a href="docs/array/0015.3sum.md">15. 三数之和 (中等)</a></li>
<li><a href="docs/array/0016.3sum-closest.md">16. 最接近的三数之和 (中等)</a></li>
<li><a href="docs/array/0018.4sum.md">18. 四数之和 (中等)</a></li>
<li><a href="docs/array/0026.remove-duplicates-from-sorted-array.md">26. 删除有序数组中的重复项 (简单)</a></li>
<li><a href="docs/array/0027.remove-element.md">27. 移除元素 (简单)</a></li>
<li><a href="docs/array/0031.next-permutation.md">31. 下一个排列 (中等)</a></li>
<li><a href="docs/array/0034.find-first-and-last-position-of-element-in-sorted-array.md">34. 在排序数组中查找元素的第一个和最后一个位置 (中等)</a></li>
<li><a href="docs/array/0069.sqrtx.md">69. x的平方根 (简单)</a></li>
<li><a href="docs/array/0088.merge-sorted-array.md">88. 合并两个有序数组 (简单)</a></li>
<li><a href="docs/array/0118.pascals-triangle.md">118. 杨辉三角 (简单)</a></li>
<li><a href="docs/array/0119.pascals-triangle-ii.md">119. 杨辉三角 II (简单)</a></li>
<li><a href="docs/array/0121.best-time-to-buy-and-sell-stock.md">121. 买卖股票的最佳时机 (简单)</a></li>
<li><a href="docs/array/0136.single-number.md">136. 只出现一次的数字 (简单)</a></li>
<li><a href="docs/array/0283.move-zeroes.md">283. 移动零 (简单)</a></li>
<li><a href="docs/array/704.binary-search.md">704. 二分查找 (简单)</a></li>
<li><a href="docs/array/1403.minimum-subsequence-in-non-increasing-order.md">1403. 非递增顺序的最小子序列 (简单)</a></li>
</ul></li>
<li>字符串
<ul>
<li><a href="docs/string/1408.string-matching-in-an-array.md">1408. 数组中的字符串匹配 (简单)</a></li>
<li><a href="docs/string/1417.reformat-the-string.md">1417. 重新格式化字符串 (简单)</a></li>
</ul></li>
<li>链表
<ul>
<li><a href="docs/linkedList/0002.add-two-numbers.md">2. 两数相加 (中等)</a></li>
</ul></li>
</ul>]]></description>
    <pubDate>Thu, 25 Aug 2022 17:05:27 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 移动零]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/array/0283.move-zeroes</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/array/0283.move-zeroes</guid>
    <description><![CDATA[<h2 id="移动零">移动零</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/move-zeroes/">https://leetcode.cn/problems/move-zeroes/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p>示例 1：</p>
<pre class="text"><code>输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入: nums = [0]
输出: [0]</code></pre>
<h2 id="解题思路">解题思路</h2>
<ul>
<li>双指针，找到第一个0，快慢指针均指向他，随后循环找到第一个不为零得数，替换快慢指针元素，随后慢指针后移，快指针++，如此往复 &gt; 执行用时： 28 ms，在所有 Go 提交中击败了 15.79% 的用户 内存消耗： 6.5 MB，在所有Go 提交中击败了 13.51% 的用户</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb3-1" title="1"><span class="co">//双指针</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">func</span> moveZeroes(nums []<span class="dt">int</span>) {</a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="kw">var</span> slowIndex <span class="dt">int</span></a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="co">//是否找到第一个0</span></a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="kw">var</span> flag <span class="dt">bool</span></a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="kw">for</span> fastIndex := <span class="dv">0</span>; fastIndex &lt; <span class="bu">len</span>(nums); fastIndex++ {</a>
<a class="sourceLine" id="cb3-7" title="7">        <span class="co">//先找到第一个0</span></a>
<a class="sourceLine" id="cb3-8" title="8">        <span class="kw">if</span> nums[fastIndex] == <span class="dv">0</span> &amp;&amp; !flag {</a>
<a class="sourceLine" id="cb3-9" title="9">            slowIndex = fastIndex</a>
<a class="sourceLine" id="cb3-10" title="10">            flag = <span class="ot">true</span></a>
<a class="sourceLine" id="cb3-11" title="11">        }</a>
<a class="sourceLine" id="cb3-12" title="12">        <span class="co">//找到之后跟后面非0得数进行对调</span></a>
<a class="sourceLine" id="cb3-13" title="13">        <span class="kw">if</span> nums[fastIndex] != <span class="dv">0</span> &amp;&amp; flag {</a>
<a class="sourceLine" id="cb3-14" title="14">            nums[slowIndex], nums[fastIndex] = nums[fastIndex], nums[slowIndex]</a>
<a class="sourceLine" id="cb3-15" title="15">            slowIndex++</a>
<a class="sourceLine" id="cb3-16" title="16">        }</a>
<a class="sourceLine" id="cb3-17" title="17">    }</a>
<a class="sourceLine" id="cb3-18" title="18">}</a></code></pre></div>
<blockquote>
<p>执行用时：28 ms，在所有 Go 提交中击败了 15.79% 的用户 内存消耗： 6.5 MB，在所有 Go 提交中击败了 97.59%的用户</p>
</blockquote>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">func</span> moveZeroes(nums []<span class="dt">int</span>) {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="kw">var</span> slowIndex <span class="dt">int</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">for</span> k, v := <span class="kw">range</span> nums {</a>
<a class="sourceLine" id="cb4-4" title="4">        <span class="kw">if</span> v == <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb4-5" title="5">            slowIndex = k</a>
<a class="sourceLine" id="cb4-6" title="6">            <span class="kw">break</span></a>
<a class="sourceLine" id="cb4-7" title="7">        }</a>
<a class="sourceLine" id="cb4-8" title="8">    }</a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="kw">for</span> fastIndex := slowIndex; fastIndex &lt; <span class="bu">len</span>(nums); fastIndex++ {</a>
<a class="sourceLine" id="cb4-10" title="10">        <span class="kw">if</span> nums[fastIndex] != <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb4-11" title="11">            nums[slowIndex], nums[fastIndex] = nums[fastIndex], nums[slowIndex]</a>
<a class="sourceLine" id="cb4-12" title="12">            slowIndex++</a>
<a class="sourceLine" id="cb4-13" title="13">        }</a>
<a class="sourceLine" id="cb4-14" title="14">    }</a>
<a class="sourceLine" id="cb4-15" title="15">}</a></code></pre></div>]]></description>
    <pubDate>Thu, 25 Aug 2022 17:05:02 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 删除有序数组中的重复项]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/array/0026.remove-duplicates-from-sorted-array</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/array/0026.remove-duplicates-from-sorted-array</guid>
    <description><![CDATA[<h2 id="删除有序数组中的重复项">删除有序数组中的重复项</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">https://leetcode.cn/problems/remove-duplicates-from-sorted-array/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p>
<p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么nums的前 k 个元素应该保存最终结果。</p>
<p>将最终结果插入nums 的前 k 个位置后返回 k 。</p>
<p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</code></pre>
<h2 id="解题思路">解题思路</h2>
<ul>
<li>双指针方法，双指针指向开头，如果两个数相同则快指针向后移动，慢指针保持不动，一旦快慢指针指向元素不想等，则后移慢指针并且将快指针的值赋给慢指针，这样就实现了每次都把新元素拿一个到前面，快指针++进入下一个循环，直到数组末尾，最终慢指针指向新数组最后一个值，慢指针+1 即为新数组长度，这样就实现了去重。 &gt; 执行用时： 8 ms，在所有 Go提交中击败了 80.00%的用户 内存消耗： 4.2 MB，在所有 Go 提交中击败了 63.66% 的用户</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">func</span> removeDuplicates(nums []<span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="kw">var</span> slowIndex <span class="dt">int</span></a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="kw">for</span> fastIndex := <span class="dv">0</span>; fastIndex &lt; <span class="bu">len</span>(nums); fastIndex++ {</a>
<a class="sourceLine" id="cb3-4" title="4">        <span class="kw">if</span> nums[slowIndex] != nums[fastIndex] {</a>
<a class="sourceLine" id="cb3-5" title="5">            slowIndex++</a>
<a class="sourceLine" id="cb3-6" title="6">            nums[slowIndex] = nums[fastIndex]</a>
<a class="sourceLine" id="cb3-7" title="7">        }</a>
<a class="sourceLine" id="cb3-8" title="8">    }</a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="kw">return</span> slowIndex + <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-10" title="10">}</a></code></pre></div>]]></description>
    <pubDate>Thu, 25 Aug 2022 16:27:40 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[说明]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/README</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/README</guid>
    <description><![CDATA[<h1 id="说明">说明</h1>
<p>LeetCode刷题记录 using Golang by zggsong with <a href="https://programmercarl.com/">代码随想录</a></p>
<p>blog <a href="//www.zggsong.cn">www.zggsong.cn</a></p>
<p>wiki <a href="//wiki.zggsong.cn">wiki.zggsong.cn</a></p>
<p>RSS <a href="//pages.zsong.ml/leetcode-doc/feed.xml">pages.zsong.ml/leetcode-doc/feed.xml</a></p>]]></description>
    <pubDate>Thu, 25 Aug 2022 16:27:40 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 移除元素]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/array/0027.remove-element</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/array/0027.remove-element</guid>
    <description><![CDATA[<h2 id="移除元素">移除元素</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/remove-element/">https://leetcode.cn/problems/remove-element/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给你一个数组 nums和一个值 val，你需要 原地 移除所有数值等于val的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<pre class="text"><code>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}</code></pre>
<p>示例 1：</p>
<pre class="text"><code>输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</code></pre>
<h2 id="解题思路">解题思路</h2>
<blockquote>
<p><a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#%E6%80%9D%E8%B7%AF">代码随想录-双指针</a></p>
</blockquote>
<ul>
<li>双指针：首先明白，去除元素本质上就是移动元素。快慢指针方式，快指针寻找就数组元素，慢指针更新新数组，如果快指针指向元素不等于需要去除元素，则将快指针元素赋给慢指针指向元素，慢指针右移，否则快指针右移，慢指针不动，如此往复即可得到满足条件新数组，长度则为慢指针指向元素下标值</li>
</ul>
<blockquote>
<p>执行用时： 4 ms，在所有 Go提交中击败了 100.00% 的用户 内存消耗： 2 MB，在所有 Go 提交中击败了 99.91% 的用户</p>
</blockquote>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">func</span> removeElement(nums []<span class="dt">int</span>, val <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="kw">var</span> slowIndex <span class="dt">int</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">for</span> fastIndex := <span class="dv">0</span>; fastIndex &lt; <span class="bu">len</span>(nums); fastIndex++ {</a>
<a class="sourceLine" id="cb4-4" title="4">        <span class="kw">if</span> nums[fastIndex] != val {</a>
<a class="sourceLine" id="cb4-5" title="5">            nums[slowIndex] = nums[fastIndex]</a>
<a class="sourceLine" id="cb4-6" title="6">            slowIndex++</a>
<a class="sourceLine" id="cb4-7" title="7">        }</a>
<a class="sourceLine" id="cb4-8" title="8">    }</a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="kw">return</span> slowIndex</a>
<a class="sourceLine" id="cb4-10" title="10">}</a></code></pre></div>]]></description>
    <pubDate>Wed, 24 Aug 2022 14:38:28 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ x的平方根]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/array/0069.sqrtx</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/array/0069.sqrtx</guid>
    <description><![CDATA[<h2 id="x的平方根">x的平方根</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/sqrtx/">https://leetcode.cn/problems/sqrtx/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给你一个非负整数 x ，计算并返回x的 算术平方根 。</p>
<p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p>
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：x = 4
输出：2</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。</code></pre>
<h2 id="解题思路">解题思路</h2>
<blockquote>
<p><a href="https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/10628618#%E7%AE%97%E6%B3%95%E8%A6%81%E6%B1%82">二分查找条件</a>：顺序存储结构、关键字按大小顺序排列</p>
</blockquote>
<ul>
<li>二分查找，整数的的算术平方根必然在[0,x]之间，除1外，当两者相差大于1才能往中间去值计算平方才能与x进行比较，否则返回左边的值(小数取整)，在循环内部则可以理解成左右均为<a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF">开区间</a>，不满足条件则分别将mid赋值给left或者right，如果正好有算术平方根则返回 &gt; 执行用时： 0 ms，在所有 Go 提交中击败了 100.00% 的用户 内存消耗： 2 MB，在所有 Go 提交中击败了 60.52% 的用户</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">func</span> mySqrt(x <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="kw">if</span> x == <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb3-3" title="3">        <span class="kw">return</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-4" title="4">    }</a>
<a class="sourceLine" id="cb3-5" title="5">    left, right := <span class="dv">0</span>, x</a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="kw">for</span> right-left &gt; <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb3-7" title="7">        mid := left + (right-left)/<span class="dv">2</span></a>
<a class="sourceLine" id="cb3-8" title="8">        <span class="kw">if</span> mid*mid &gt; x {</a>
<a class="sourceLine" id="cb3-9" title="9">            right = mid</a>
<a class="sourceLine" id="cb3-10" title="10">        } <span class="kw">else</span> <span class="kw">if</span> mid*mid &lt; x {</a>
<a class="sourceLine" id="cb3-11" title="11">            left = mid</a>
<a class="sourceLine" id="cb3-12" title="12">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb3-13" title="13">            <span class="kw">return</span> mid</a>
<a class="sourceLine" id="cb3-14" title="14">        }</a>
<a class="sourceLine" id="cb3-15" title="15">    }</a>
<a class="sourceLine" id="cb3-16" title="16">    <span class="kw">return</span> left</a>
<a class="sourceLine" id="cb3-17" title="17">}</a></code></pre></div>
<ul>
<li>二分查找，典型的<a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF">左闭右开</a>，条件<code>l&lt;r</code> &gt; 执行用时： 0 ms，在所有 Go 提交中击败了 100.00% 的用户 内存消耗： 2 MB，在所有 Go 提交中击败了 60.52% 的用户</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">func</span> mySqrt(x <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb4-2" title="2">    l, r := <span class="dv">0</span>, x</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">for</span> l &lt; r {</a>
<a class="sourceLine" id="cb4-4" title="4">        mid := (l + r + <span class="dv">1</span>) / <span class="dv">2</span></a>
<a class="sourceLine" id="cb4-5" title="5">        <span class="kw">if</span> mid*mid &gt; x {</a>
<a class="sourceLine" id="cb4-6" title="6">            r = mid - <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-7" title="7">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb4-8" title="8">            l = mid</a>
<a class="sourceLine" id="cb4-9" title="9">        }</a>
<a class="sourceLine" id="cb4-10" title="10">    }</a>
<a class="sourceLine" id="cb4-11" title="11">    <span class="kw">return</span> l</a>
<a class="sourceLine" id="cb4-12" title="12">}</a></code></pre></div>
<ul>
<li>牛顿迭代法, <a href="https://en.wikipedia.org/wiki/Integer_square_root">https://en.wikipedia.org/wiki/Integer_square_root</a>，求根号 x，即求满足 x^2 - n = 0 方程的所有解。 &gt; 执行用时： 4 ms，在所有 Go 提交中击败了 43.85% 的用户 内存消耗： 2 MB，在所有 Go 提交中击败了 99.83% 的用户</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">func</span> mySqrt(x <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb5-2" title="2">    r := x</a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="kw">for</span> r*r &gt; x {</a>
<a class="sourceLine" id="cb5-4" title="4">        r = (r + x/r) / <span class="dv">2</span></a>
<a class="sourceLine" id="cb5-5" title="5">    }</a>
<a class="sourceLine" id="cb5-6" title="6">    <span class="kw">return</span> r</a>
<a class="sourceLine" id="cb5-7" title="7">}</a></code></pre></div>]]></description>
    <pubDate>Wed, 24 Aug 2022 11:38:38 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 在排序数组中查找元素的第一个和最后一个位置]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/array/0034.find-first-and-last-position-of-element-in-sorted-array</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/array/0034.find-first-and-last-position-of-element-in-sorted-array</guid>
    <description><![CDATA[<h2 id="在排序数组中查找元素的第一个和最后一个位置">在排序数组中查找元素的第一个和最后一个位置</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回[-1, -1]。</p>
<p>你必须设计并实现时间复杂度为O(log n)的算法解决此问题。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]</code></pre>
<p>示例 3：</p>
<pre><code>输入：nums = [], target = 0
输出：[-1,-1]</code></pre>
<h2 id="解题思路">解题思路</h2>
<ul>
<li>分为三种情况：1. 数组范围外，2. 数组范围内且存在，3. 数组范围内且不存在。先判断是否在数组外，如果在随后使用二分法，根据题意使用左闭右闭的方式(即<code>left&lt;=right</code>)，在mid==target的条件下往左查找开始位置，往右查找结束位置，注意数组边界；如果始终不满足mid==target条件，则返回[-1,-1] &gt; 执行用时： 4 ms，在所有Go提交中击败了 96.19% 的用户 内存消耗： 3.8 MB， 在所有 Go 提交中击败了 57.76% 的用户</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">func</span> searchRange(nums []<span class="dt">int</span>, target <span class="dt">int</span>) []<span class="dt">int</span> {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="co">//1. 在数组外</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">if</span> <span class="bu">len</span>(nums) == <span class="dv">0</span> || nums[<span class="dv">0</span>] &gt; target || nums[<span class="bu">len</span>(nums)-<span class="dv">1</span>] &lt; target {</a>
<a class="sourceLine" id="cb4-4" title="4">        <span class="kw">return</span> []<span class="dt">int</span>{-<span class="dv">1</span>, <span class="dv">-1</span>}</a>
<a class="sourceLine" id="cb4-5" title="5">    }</a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="co">//2. 在数组内</span></a>
<a class="sourceLine" id="cb4-7" title="7">    left, right := <span class="dv">0</span>, <span class="bu">len</span>(nums)-<span class="dv">1</span></a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="kw">var</span> ret []<span class="dt">int</span></a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="kw">for</span> left &lt;= right {</a>
<a class="sourceLine" id="cb4-10" title="10">        mid := left + (right-left)/<span class="dv">2</span></a>
<a class="sourceLine" id="cb4-11" title="11">        <span class="kw">if</span> nums[mid] &lt; target {</a>
<a class="sourceLine" id="cb4-12" title="12">            left = mid + <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-13" title="13">        } <span class="kw">else</span> <span class="kw">if</span> nums[mid] &gt; target {</a>
<a class="sourceLine" id="cb4-14" title="14">            right = mid - <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-15" title="15">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb4-16" title="16">            <span class="co">//2.1 在数组范围内且存在</span></a>
<a class="sourceLine" id="cb4-17" title="17">            mid2 := mid</a>
<a class="sourceLine" id="cb4-18" title="18">            <span class="kw">for</span> mid<span class="dv">-1</span> &gt;= <span class="dv">0</span> &amp;&amp; nums[mid<span class="dv">-1</span>] == target {</a>
<a class="sourceLine" id="cb4-19" title="19">                mid--</a>
<a class="sourceLine" id="cb4-20" title="20">            }</a>
<a class="sourceLine" id="cb4-21" title="21">            ret = <span class="bu">append</span>(ret, mid)</a>
<a class="sourceLine" id="cb4-22" title="22">            <span class="kw">for</span> mid2+<span class="dv">1</span> &lt;= <span class="bu">len</span>(nums)-<span class="dv">1</span> &amp;&amp; nums[mid2+<span class="dv">1</span>] == target {</a>
<a class="sourceLine" id="cb4-23" title="23">                mid2++</a>
<a class="sourceLine" id="cb4-24" title="24">            }</a>
<a class="sourceLine" id="cb4-25" title="25">            ret = <span class="bu">append</span>(ret, mid2)</a>
<a class="sourceLine" id="cb4-26" title="26">            <span class="kw">return</span> ret</a>
<a class="sourceLine" id="cb4-27" title="27">        }</a>
<a class="sourceLine" id="cb4-28" title="28">    }</a>
<a class="sourceLine" id="cb4-29" title="29">    <span class="co">//2.2 在数组范围内且不存在</span></a>
<a class="sourceLine" id="cb4-30" title="30">    <span class="kw">return</span> []<span class="dt">int</span>{-<span class="dv">1</span>, <span class="dv">-1</span>}</a>
<a class="sourceLine" id="cb4-31" title="31">}</a></code></pre></div>
<ul>
<li>来自<a href="https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0034.Find-First-and-Last-Position-of-Element-in-Sorted-Array/">LeetCodeCookBook</a> 也是从三种情况入手，不过处理方式是分别处理开始位置和结束位置</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">func</span> searchRange(nums []<span class="dt">int</span>, target <span class="dt">int</span>) []<span class="dt">int</span> {</a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="kw">return</span> []<span class="dt">int</span>{searchFirstEqualElement(nums, target), searchLastEqualElement(nums, target)}</a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4">}</a>
<a class="sourceLine" id="cb5-5" title="5"></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="co">// 二分查找第一个与 target 相等的元素，时间复杂度 O(logn)</span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="kw">func</span> searchFirstEqualElement(nums []<span class="dt">int</span>, target <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb5-8" title="8">    low, high := <span class="dv">0</span>, <span class="bu">len</span>(nums)-<span class="dv">1</span></a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="kw">for</span> low &lt;= high {</a>
<a class="sourceLine" id="cb5-10" title="10">        mid := low + ((high - low) &gt;&gt; <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb5-11" title="11">        <span class="kw">if</span> nums[mid] &gt; target {</a>
<a class="sourceLine" id="cb5-12" title="12">            high = mid - <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-13" title="13">        } <span class="kw">else</span> <span class="kw">if</span> nums[mid] &lt; target {</a>
<a class="sourceLine" id="cb5-14" title="14">            low = mid + <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-15" title="15">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb5-16" title="16">            <span class="kw">if</span> (mid == <span class="dv">0</span>) || (nums[mid<span class="dv">-1</span>] != target) { <span class="co">// 找到第一个与 target 相等的元素</span></a>
<a class="sourceLine" id="cb5-17" title="17">                <span class="kw">return</span> mid</a>
<a class="sourceLine" id="cb5-18" title="18">            }</a>
<a class="sourceLine" id="cb5-19" title="19">            high = mid - <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-20" title="20">        }</a>
<a class="sourceLine" id="cb5-21" title="21">    }</a>
<a class="sourceLine" id="cb5-22" title="22">    <span class="kw">return</span> <span class="dv">-1</span></a>
<a class="sourceLine" id="cb5-23" title="23">}</a>
<a class="sourceLine" id="cb5-24" title="24"></a>
<a class="sourceLine" id="cb5-25" title="25"><span class="co">// 二分查找最后一个与 target 相等的元素，时间复杂度 O(logn)</span></a>
<a class="sourceLine" id="cb5-26" title="26"><span class="kw">func</span> searchLastEqualElement(nums []<span class="dt">int</span>, target <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb5-27" title="27">    low, high := <span class="dv">0</span>, <span class="bu">len</span>(nums)-<span class="dv">1</span></a>
<a class="sourceLine" id="cb5-28" title="28">    <span class="kw">for</span> low &lt;= high {</a>
<a class="sourceLine" id="cb5-29" title="29">        mid := low + ((high - low) &gt;&gt; <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb5-30" title="30">        <span class="kw">if</span> nums[mid] &gt; target {</a>
<a class="sourceLine" id="cb5-31" title="31">            high = mid - <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-32" title="32">        } <span class="kw">else</span> <span class="kw">if</span> nums[mid] &lt; target {</a>
<a class="sourceLine" id="cb5-33" title="33">            low = mid + <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-34" title="34">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb5-35" title="35">            <span class="kw">if</span> (mid == <span class="bu">len</span>(nums)-<span class="dv">1</span>) || (nums[mid+<span class="dv">1</span>] != target) { <span class="co">// 找到最后一个与 target 相等的元素</span></a>
<a class="sourceLine" id="cb5-36" title="36">                <span class="kw">return</span> mid</a>
<a class="sourceLine" id="cb5-37" title="37">            }</a>
<a class="sourceLine" id="cb5-38" title="38">            low = mid + <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-39" title="39">        }</a>
<a class="sourceLine" id="cb5-40" title="40">    }</a>
<a class="sourceLine" id="cb5-41" title="41">    <span class="kw">return</span> <span class="dv">-1</span></a>
<a class="sourceLine" id="cb5-42" title="42">}</a></code></pre></div>]]></description>
    <pubDate>Tue, 23 Aug 2022 19:52:22 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 重新格式化字符串]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/string/1417.reformat-the-string</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/string/1417.reformat-the-string</guid>
    <description><![CDATA[<h2 id="重新格式化字符串">重新格式化字符串</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/reformat-the-string/">https://leetcode.cn/problems/reformat-the-string/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。</p>
<p>请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。</p>
<p>请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：s = &quot;a0b1c2&quot;
输出：&quot;0a1b2c&quot;
解释：&quot;0a1b2c&quot; 中任意两个相邻字符的类型都不同。 &quot;a0b1c2&quot;, &quot;0a1b2c&quot;, &quot;0c2a1b&quot; 也是满足题目要求的答案。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：s = &quot;leetcode&quot;
输出：&quot;&quot;
解释：&quot;leetcode&quot; 中只有字母，所以无法满足重新格式化的条件。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：s = &quot;leetcode&quot;
输出：&quot;&quot;
解释：&quot;leetcode&quot; 中只有字母，所以无法满足重新格式化的条件。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：s = &quot;leetcode&quot;
输出：&quot;&quot;
解释：&quot;leetcode&quot; 中只有字母，所以无法满足重新格式化的条件。</code></pre>
<p>示例 3：</p>
<pre class="text"><code>输入：s = &quot;1229857369&quot;
输出：&quot;&quot;
解释：&quot;1229857369&quot; 中只有数字，所以无法满足重新格式化的条件。</code></pre>
<p>示例 4：</p>
<pre class="text"><code>输入：s = &quot;covid2019&quot;
输出：&quot;c2o0v1i9d&quot;输入：s = &quot;covid2019&quot;
输出：&quot;c2o0v1i9d&quot;</code></pre>
<p>示例5：</p>
<pre class="text"><code>输入：s = &quot;ab123&quot;
输出：&quot;1a2b3&quot;</code></pre>
<h2 id="解题思路">解题思路</h2>
<ul>
<li>数组暴力解法：分割成两个数组，字符数组，数字数组，然后去除不满足的情况（两个数组长度之差超过1的则为不满足）随后判断谁大，那个先添加到字符串中，直至添加完成 &gt; 执行用时： 4 ms，在所有Go提交中击败了 22.86％ 的用户 内存消耗： 6.6 MB，在所有 Go 提交中击败了 17.14% 的用户</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">func</span> reformat(s <span class="dt">string</span>) <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb8-2" title="2">    ret, c1, c2 := <span class="st">&quot;&quot;</span>, []<span class="dt">string</span>{}, []<span class="dt">string</span>{}</a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="kw">for</span> _, v := <span class="kw">range</span> s {</a>
<a class="sourceLine" id="cb8-4" title="4">        <span class="kw">if</span> v &gt;= <span class="dv">48</span> &amp;&amp; v &lt;= <span class="dv">57</span> {</a>
<a class="sourceLine" id="cb8-5" title="5">            c1 = <span class="bu">append</span>(c1, <span class="dt">string</span>(v))</a>
<a class="sourceLine" id="cb8-6" title="6">            <span class="kw">continue</span></a>
<a class="sourceLine" id="cb8-7" title="7">        }</a>
<a class="sourceLine" id="cb8-8" title="8">        c2 = <span class="bu">append</span>(c2, <span class="dt">string</span>(v))</a>
<a class="sourceLine" id="cb8-9" title="9">    }</a>
<a class="sourceLine" id="cb8-10" title="10">    sub := <span class="bu">len</span>(c1) - <span class="bu">len</span>(c2)</a>
<a class="sourceLine" id="cb8-11" title="11">    <span class="kw">if</span> sub &lt;= <span class="dv">1</span> &amp;&amp; sub &gt;= <span class="dv">-1</span> {</a>
<a class="sourceLine" id="cb8-12" title="12">        <span class="kw">if</span> sub &lt; <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb8-13" title="13">            c1, c2 = c2, c1</a>
<a class="sourceLine" id="cb8-14" title="14">        }</a>
<a class="sourceLine" id="cb8-15" title="15">        <span class="kw">for</span> i := <span class="kw">range</span> c2 {</a>
<a class="sourceLine" id="cb8-16" title="16">            ret += c1[i] + c2[i]</a>
<a class="sourceLine" id="cb8-17" title="17">        }</a>
<a class="sourceLine" id="cb8-18" title="18">        <span class="kw">if</span> sub != <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb8-19" title="19">            ret += c1[<span class="bu">len</span>(c1)-<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb8-20" title="20">        }</a>
<a class="sourceLine" id="cb8-21" title="21">    }</a>
<a class="sourceLine" id="cb8-22" title="22">    <span class="kw">return</span> ret</a>
<a class="sourceLine" id="cb8-23" title="23">}</a></code></pre></div>
<ul>
<li>字符串暴力解法：方法同数组解法 &gt; 执行用时：8ms，在所有 Go 提交中击败了 14.29% 的用户 内存消耗：6.7 MB，在所有Go提交中击败了 11.43% 的用户</li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">func</span> reformat(s <span class="dt">string</span>) <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb9-2" title="2">    s1, s2 := <span class="st">&quot;&quot;</span>, <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="kw">for</span> _, v := <span class="kw">range</span> s {</a>
<a class="sourceLine" id="cb9-4" title="4">        <span class="kw">if</span> v &gt;= <span class="dv">48</span> &amp;&amp; v &lt;= <span class="dv">57</span> {</a>
<a class="sourceLine" id="cb9-5" title="5">            s1 += <span class="dt">string</span>(v)</a>
<a class="sourceLine" id="cb9-6" title="6">            <span class="kw">continue</span></a>
<a class="sourceLine" id="cb9-7" title="7">        }</a>
<a class="sourceLine" id="cb9-8" title="8">        s2 += <span class="dt">string</span>(v)</a>
<a class="sourceLine" id="cb9-9" title="9">    }</a>
<a class="sourceLine" id="cb9-10" title="10">    <span class="kw">if</span> <span class="bu">len</span>(s1)-<span class="bu">len</span>(s2) &lt;= <span class="dv">1</span> &amp;&amp; <span class="bu">len</span>(s1)-<span class="bu">len</span>(s2) &gt;= <span class="dv">-1</span> {</a>
<a class="sourceLine" id="cb9-11" title="11">        <span class="kw">if</span> <span class="bu">len</span>(s1) &lt; <span class="bu">len</span>(s2) {</a>
<a class="sourceLine" id="cb9-12" title="12">            s1, s2 = s2, s1</a>
<a class="sourceLine" id="cb9-13" title="13">        }</a>
<a class="sourceLine" id="cb9-14" title="14">        ret := <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb9-15" title="15">        <span class="kw">for</span> i, _ := <span class="kw">range</span> s2 {</a>
<a class="sourceLine" id="cb9-16" title="16">            ret += <span class="dt">string</span>(s1[i]) + <span class="dt">string</span>(s2[i])</a>
<a class="sourceLine" id="cb9-17" title="17">        }</a>
<a class="sourceLine" id="cb9-18" title="18">        <span class="kw">if</span> <span class="bu">len</span>(s1) != <span class="bu">len</span>(s2) {</a>
<a class="sourceLine" id="cb9-19" title="19">            ret += <span class="dt">string</span>(s1[<span class="bu">len</span>(s1)-<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb9-20" title="20">        }</a>
<a class="sourceLine" id="cb9-21" title="21">        <span class="kw">return</span> ret</a>
<a class="sourceLine" id="cb9-22" title="22">    }</a>
<a class="sourceLine" id="cb9-23" title="23">    <span class="kw">return</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb9-24" title="24">}</a></code></pre></div>]]></description>
    <pubDate>Wed, 17 Aug 2022 17:09:26 +0800</pubDate>
  </item>
  
</channel>
</rss>
