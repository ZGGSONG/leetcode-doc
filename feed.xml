<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
<channel>
  <title>LeetCode刷题记录</title>
  <atom:link href="https://pages.zsong.ml/leetcode-doc/feed.xml" rel="self" type="application/rss+xml" />
  <link>https://pages.zsong.ml/leetcode-doc</link>
  <description>LeetCode刷题记录</description>
   
  <item>
    <title><![CDATA[ 水果成篮]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/array/0904.fruit-into-baskets</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/array/0904.fruit-into-baskets</guid>
    <description><![CDATA[<h2 id="水果成篮">水果成篮</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/fruit-into-baskets/">https://leetcode.cn/problems/fruit-into-baskets/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p>
<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>
<p>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：fruits = [1,2,1]
输出：3
解释：可以采摘全部 3 棵树。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：fruits = [0,1,2,2]
输出：3
解释：可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</code></pre>
<p>示例3：</p>
<pre class="text"><code>输入：fruits = [1,2,3,2,2]
输出：4
解释：可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。</code></pre>
<p>示例4：</p>
<pre class="text"><code>输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：可以采摘 [1,2,1,1,2] 这五棵树。</code></pre>
<h2 id="解题思路">解题思路</h2>
<ul>
<li>解析题意：题目表达的是一个整数数组，按照一定的规则排列，从左往右读，只能读两种数字，每读完一次向右移，可以重复，一旦遇到第三个不同的数字，则立即停止读，最后得出只有两种数字的情况下最长的子数组的情况，并输出子数组长度</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">func</span> totalFruit(fruits []<span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb5-2" title="2">    totalMap := <span class="bu">make</span>(<span class="kw">map</span>[<span class="dt">int</span>]<span class="dt">int</span>) <span class="co">//定义一个map存储符合条件的数</span></a>
<a class="sourceLine" id="cb5-3" title="3">    slowIndex, fastIndex := <span class="dv">0</span>, <span class="dv">0</span>  <span class="co">//定义双指针指针</span></a>
<a class="sourceLine" id="cb5-4" title="4">    ret := <span class="dv">0</span>                      <span class="co">//定义一个值来存储符合条件子数组的最大长度</span></a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="kw">for</span> ; fastIndex &lt; <span class="bu">len</span>(fruits); fastIndex++ {</a>
<a class="sourceLine" id="cb5-6" title="6">        totalMap[fruits[fastIndex]]++ <span class="co">//向map中存储数</span></a>
<a class="sourceLine" id="cb5-7" title="7">        <span class="kw">for</span> <span class="bu">len</span>(totalMap) &gt; <span class="dv">2</span> {       <span class="co">//当map中key的数量超过两个则可以计算子数组</span></a>
<a class="sourceLine" id="cb5-8" title="8">            tmp := fastIndex - slowIndex <span class="co">//计算当前符合条件子数组长度</span></a>
<a class="sourceLine" id="cb5-9" title="9">            <span class="kw">if</span> tmp &gt; ret {               <span class="co">//如果当前长度大于之前的最大长度，则更新最大长度</span></a>
<a class="sourceLine" id="cb5-10" title="10">                ret = tmp</a>
<a class="sourceLine" id="cb5-11" title="11">            }</a>
<a class="sourceLine" id="cb5-12" title="12">            totalMap[fruits[slowIndex]]--</a>
<a class="sourceLine" id="cb5-13" title="13">            <span class="kw">if</span> totalMap[fruits[slowIndex]] == <span class="dv">0</span> { <span class="co">//当map fruits[slowIndex]的value减1后等于零则删除这个键</span></a>
<a class="sourceLine" id="cb5-14" title="14">                <span class="bu">delete</span>(totalMap, fruits[slowIndex])</a>
<a class="sourceLine" id="cb5-15" title="15">            }</a>
<a class="sourceLine" id="cb5-16" title="16">            slowIndex++ <span class="co">//慢指针向后移动</span></a>
<a class="sourceLine" id="cb5-17" title="17">        }</a>
<a class="sourceLine" id="cb5-18" title="18">    }</a>
<a class="sourceLine" id="cb5-19" title="19">    tmp := fastIndex - slowIndex <span class="co">//快指针读完整个数组后再次判断快慢指针之间的长度是否大于最大长度</span></a>
<a class="sourceLine" id="cb5-20" title="20">    <span class="kw">if</span> tmp &gt; ret {</a>
<a class="sourceLine" id="cb5-21" title="21">        ret = tmp</a>
<a class="sourceLine" id="cb5-22" title="22">    }</a>
<a class="sourceLine" id="cb5-23" title="23">    <span class="kw">return</span> ret</a>
<a class="sourceLine" id="cb5-24" title="24">}</a></code></pre></div>]]></description>
    <pubDate>Tue, 30 Aug 2022 10:41:41 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[开始]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/_sidebar</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/_sidebar</guid>
    <description><![CDATA[<ul>
<li>开始
<ul>
<li><a href="README.md">说明</a></li>
</ul></li>
<li>方法
<ul>
<li><a href="docs/methods/binary-search.md">二分查找</a></li>
<li><a href="docs/methods/double-pointer.md">双指针法</a></li>
</ul></li>
<li>数组
<ul>
<li><a href="docs/array/0001.two-sum.md">1. 两数之和 (简单)</a></li>
<li><a href="docs/array/0011.container-with-most-water.md">11. 盛最多水的容器 (中等)</a></li>
<li><a href="docs/array/0015.3sum.md">15. 三数之和 (中等)</a></li>
<li><a href="docs/array/0016.3sum-closest.md">16. 最接近的三数之和 (中等)</a></li>
<li><a href="docs/array/0018.4sum.md">18. 四数之和 (中等)</a></li>
<li><a href="docs/array/0026.remove-duplicates-from-sorted-array.md">26. 删除有序数组中的重复项 (简单)</a></li>
<li><a href="docs/array/0027.remove-element.md">27. 移除元素 (简单)</a></li>
<li><a href="docs/array/0031.next-permutation.md">31. 下一个排列 (中等)</a></li>
<li><a href="docs/array/0034.find-first-and-last-position-of-element-in-sorted-array.md">34. 在排序数组中查找元素的第一个和最后一个位置 (中等)</a></li>
<li><a href="docs/array/0069.sqrtx.md">69. x的平方根 (简单)</a></li>
<li><a href="docs/array/0088.merge-sorted-array.md">88. 合并两个有序数组 (简单)</a></li>
<li><a href="docs/array/0118.pascals-triangle.md">118. 杨辉三角 (简单)</a></li>
<li><a href="docs/array/0119.pascals-triangle-ii.md">119. 杨辉三角 II (简单)</a></li>
<li><a href="docs/array/0121.best-time-to-buy-and-sell-stock.md">121. 买卖股票的最佳时机 (简单)</a></li>
<li><a href="docs/array/0136.single-number.md">136. 只出现一次的数字 (简单)</a></li>
<li><a href="docs/array/0209.minimum-size-subarray-sum.md">209. 长度最小的子数组 (中等)</a></li>
<li><a href="docs/array/0283.move-zeroes.md">283. 移动零 (简单)</a></li>
<li><a href="docs/array/704.binary-search.md">704. 二分查找 (简单)</a></li>
<li><a href="docs/array/0904.fruit-into-baskets.md">904. 水果成篮 (中等)</a></li>
<li><a href="docs/array/0977.squares-of-a-sorted-array.md">977. 有序数组的平方 (简单)</a></li>
<li><a href="docs/array/1403.minimum-subsequence-in-non-increasing-order.md">1403. 非递增顺序的最小子序列 (简单)</a></li>
</ul></li>
<li>字符串
<ul>
<li><a href="docs/string/1408.string-matching-in-an-array.md">1408. 数组中的字符串匹配 (简单)</a></li>
<li><a href="docs/string/1417.reformat-the-string.md">1417. 重新格式化字符串 (简单)</a></li>
</ul></li>
<li>链表
<ul>
<li><a href="docs/linkedList/0002.add-two-numbers.md">2. 两数相加 (中等)</a></li>
</ul></li>
</ul>]]></description>
    <pubDate>Tue, 30 Aug 2022 10:41:41 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[说明]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/README</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/README</guid>
    <description><![CDATA[<h1 id="说明">说明</h1>
<p>LeetCode刷题记录 using Golang by <a href="//zggsong.cn">zggsong</a> with <a href="https://programmercarl.com/">代码随想录</a></p>
<p>blog <a href="//www.zggsong.cn">www.zggsong.cn</a></p>
<p>wiki <a href="//wiki.zggsong.cn">wiki.zggsong.cn</a></p>
<p>RSS <a href="//pages.zsong.ml/leetcode-doc/feed.xml">pages.zsong.ml/leetcode-doc/feed.xml</a></p>]]></description>
    <pubDate>Sun, 28 Aug 2022 20:19:51 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 长度最小的子数组]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/array/0209.minimum-size-subarray-sum</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/array/0209.minimum-size-subarray-sum</guid>
    <description><![CDATA[<h2 id="长度最小的子数组">长度最小的子数组</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">https://leetcode.cn/problems/minimum-size-subarray-sum/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给定一个含有n个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组[numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：target = 4, nums = [1,4,4]
输出：1</code></pre>
<h2 id="解题思路">解题思路</h2>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" /></p>
<blockquote>
<p>上图来自<a href="https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">代码随想录</a></p>
</blockquote>
<ul>
<li>滑动窗口(双指针): 需要重复遍历数组，必然不能用O(n^2)的暴力解法，所以使用双指针法，思路主要根据上面动图展示，进行实现。双指针指向数组头，快指针右移，且子数组累加，直到子数组和大于等于target，则进入循环判断子数组和是否大于等于target，计算保存子数组长度是否小于当前result所存最小长度，满足则更新result，右移慢指针，且子数组减去原慢指针元素</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">func</span> minSubArrayLen(target <span class="dt">int</span>, nums []<span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb3-2" title="2">   i := <span class="dv">0</span></a>
<a class="sourceLine" id="cb3-3" title="3">   l := <span class="bu">len</span>(nums)  <span class="co">// 数组长度</span></a>
<a class="sourceLine" id="cb3-4" title="4">   sum := <span class="dv">0</span>        <span class="co">// 子数组之和</span></a>
<a class="sourceLine" id="cb3-5" title="5">   result := l + <span class="dv">1</span> <span class="co">// 初始化返回长度为l+1，目的是为了判断“不存在符合条件的子数组，返回0”的情况</span></a>
<a class="sourceLine" id="cb3-6" title="6">   <span class="kw">for</span> j := <span class="dv">0</span>; j &lt; l; j++ {</a>
<a class="sourceLine" id="cb3-7" title="7">       sum += nums[j]</a>
<a class="sourceLine" id="cb3-8" title="8">       <span class="kw">for</span> sum &gt;= target {</a>
<a class="sourceLine" id="cb3-9" title="9">           subLength := j - i + <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-10" title="10">           <span class="kw">if</span> subLength &lt; result {</a>
<a class="sourceLine" id="cb3-11" title="11">               result = subLength</a>
<a class="sourceLine" id="cb3-12" title="12">           }</a>
<a class="sourceLine" id="cb3-13" title="13">           sum -= nums[i]</a>
<a class="sourceLine" id="cb3-14" title="14">           i++</a>
<a class="sourceLine" id="cb3-15" title="15">       }</a>
<a class="sourceLine" id="cb3-16" title="16">   }</a>
<a class="sourceLine" id="cb3-17" title="17">   <span class="kw">if</span> result == l+<span class="dv">1</span> {</a>
<a class="sourceLine" id="cb3-18" title="18">       <span class="kw">return</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb3-19" title="19">   } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb3-20" title="20">       <span class="kw">return</span> result</a>
<a class="sourceLine" id="cb3-21" title="21">   }</a>
<a class="sourceLine" id="cb3-22" title="22">}</a></code></pre></div>
<ul>
<li>自己写的滑动窗口，稍稍繁琐了点，主要在于针对满足条件情况下，可以使用for替代条件判断，避免忽略快指针固定且慢指针右移后的情况下有最优解，即第一种解法</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">func</span> minSubArrayLen(target <span class="dt">int</span>, nums []<span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="kw">var</span> ret = math.MaxInt</a>
<a class="sourceLine" id="cb4-3" title="3">    i, j, sum := <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span></a>
<a class="sourceLine" id="cb4-4" title="4">    flag := <span class="ot">true</span></a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="co">//遍历数组</span></a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="kw">for</span> j &lt; <span class="bu">len</span>(nums) {</a>
<a class="sourceLine" id="cb4-7" title="7">        <span class="kw">if</span> flag {</a>
<a class="sourceLine" id="cb4-8" title="8">            sum += nums[j]</a>
<a class="sourceLine" id="cb4-9" title="9">        }</a>
<a class="sourceLine" id="cb4-10" title="10">        <span class="kw">if</span> sum &gt;= target {</a>
<a class="sourceLine" id="cb4-11" title="11">            tmp := j - i + <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-12" title="12">            <span class="kw">if</span> tmp &lt; ret {</a>
<a class="sourceLine" id="cb4-13" title="13">                ret = tmp</a>
<a class="sourceLine" id="cb4-14" title="14">            }</a>
<a class="sourceLine" id="cb4-15" title="15">            sum -= nums[i]</a>
<a class="sourceLine" id="cb4-16" title="16">            i++</a>
<a class="sourceLine" id="cb4-17" title="17">            flag = <span class="ot">false</span></a>
<a class="sourceLine" id="cb4-18" title="18">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb4-19" title="19">            j++</a>
<a class="sourceLine" id="cb4-20" title="20">            flag = <span class="ot">true</span></a>
<a class="sourceLine" id="cb4-21" title="21">        }</a>
<a class="sourceLine" id="cb4-22" title="22">    }</a>
<a class="sourceLine" id="cb4-23" title="23">    <span class="co">//如果没有符合条件</span></a>
<a class="sourceLine" id="cb4-24" title="24">    <span class="kw">if</span> ret == math.MaxInt {</a>
<a class="sourceLine" id="cb4-25" title="25">        ret = <span class="dv">0</span></a>
<a class="sourceLine" id="cb4-26" title="26">    }</a>
<a class="sourceLine" id="cb4-27" title="27">    <span class="kw">return</span> ret</a>
<a class="sourceLine" id="cb4-28" title="28">}</a></code></pre></div>]]></description>
    <pubDate>Fri, 26 Aug 2022 14:49:07 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 有序数组的平方]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/array/0977.squares-of-a-sorted-array</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/array/0977.squares-of-a-sorted-array</guid>
    <description><![CDATA[<h2 id="有序数组的平方">有序数组的平方</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]</code></pre>
<h2 id="解题思路">解题思路</h2>
<ul>
<li>暴力解法：先平方后排序O(log(n))</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">func</span> sortedSquares(nums []<span class="dt">int</span>) []<span class="dt">int</span> {</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="co">//先平方</span></a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="kw">for</span> i, _ := <span class="kw">range</span> nums {</a>
<a class="sourceLine" id="cb3-4" title="4">        nums[i] *= nums[i]</a>
<a class="sourceLine" id="cb3-5" title="5">    }</a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="co">//冒号排序</span></a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="bu">len</span>(nums)-<span class="dv">1</span>; i++ {</a>
<a class="sourceLine" id="cb3-8" title="8">        <span class="kw">for</span> j := <span class="dv">0</span>; j &lt; <span class="bu">len</span>(nums)-i<span class="dv">-1</span>; j++ {</a>
<a class="sourceLine" id="cb3-9" title="9">            <span class="kw">if</span> nums[j] &gt; nums[j+<span class="dv">1</span>] {</a>
<a class="sourceLine" id="cb3-10" title="10">                nums[j], nums[j+<span class="dv">1</span>] = nums[j+<span class="dv">1</span>], nums[j]</a>
<a class="sourceLine" id="cb3-11" title="11">            }</a>
<a class="sourceLine" id="cb3-12" title="12">        }</a>
<a class="sourceLine" id="cb3-13" title="13">    }</a>
<a class="sourceLine" id="cb3-14" title="14">    <span class="kw">return</span> nums</a>
<a class="sourceLine" id="cb3-15" title="15">}</a></code></pre></div>
<ul>
<li>双指针法：由于是非递减序列，那就是两头大，中间小，双指针分别指向两端，比较指针元素平方后大小，大的添加至新数组尾部，相应的指针想中间移动，依次往前填充即可O(n)</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">func</span> sortedSquares(nums []<span class="dt">int</span>) []<span class="dt">int</span> {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="kw">var</span> length = <span class="bu">len</span>(nums)</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">var</span> ret = <span class="bu">make</span>([]<span class="dt">int</span>, length)</a>
<a class="sourceLine" id="cb4-4" title="4">    slowIndex, fastIndex, index := <span class="dv">0</span>, length<span class="dv">-1</span>, length<span class="dv">-1</span></a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="kw">for</span> slowIndex &lt;= fastIndex {</a>
<a class="sourceLine" id="cb4-6" title="6">        slowSquare, fastSquare := nums[slowIndex]*nums[slowIndex], nums[fastIndex]*nums[fastIndex]</a>
<a class="sourceLine" id="cb4-7" title="7">        <span class="kw">if</span> slowSquare &gt; fastSquare {</a>
<a class="sourceLine" id="cb4-8" title="8">            ret[index] = slowSquare</a>
<a class="sourceLine" id="cb4-9" title="9">            slowIndex++</a>
<a class="sourceLine" id="cb4-10" title="10">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb4-11" title="11">            ret[index] = fastSquare</a>
<a class="sourceLine" id="cb4-12" title="12">            fastIndex--</a>
<a class="sourceLine" id="cb4-13" title="13"></a>
<a class="sourceLine" id="cb4-14" title="14">        }</a>
<a class="sourceLine" id="cb4-15" title="15">        index--</a>
<a class="sourceLine" id="cb4-16" title="16">    }</a>
<a class="sourceLine" id="cb4-17" title="17">    <span class="kw">return</span> ret</a>
<a class="sourceLine" id="cb4-18" title="18">}</a></code></pre></div>]]></description>
    <pubDate>Fri, 26 Aug 2022 11:11:38 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 移动零]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/array/0283.move-zeroes</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/array/0283.move-zeroes</guid>
    <description><![CDATA[<h2 id="移动零">移动零</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/move-zeroes/">https://leetcode.cn/problems/move-zeroes/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p>示例 1：</p>
<pre class="text"><code>输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入: nums = [0]
输出: [0]</code></pre>
<h2 id="解题思路">解题思路</h2>
<ul>
<li>双指针，找到第一个0，快慢指针均指向他，随后循环找到第一个不为零得数，替换快慢指针元素，随后慢指针后移，快指针++，如此往复</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb3-1" title="1"><span class="co">//双指针</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">func</span> moveZeroes(nums []<span class="dt">int</span>) {</a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="kw">var</span> slowIndex <span class="dt">int</span></a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="co">//是否找到第一个0</span></a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="kw">var</span> flag <span class="dt">bool</span></a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="kw">for</span> fastIndex := <span class="dv">0</span>; fastIndex &lt; <span class="bu">len</span>(nums); fastIndex++ {</a>
<a class="sourceLine" id="cb3-7" title="7">        <span class="co">//先找到第一个0</span></a>
<a class="sourceLine" id="cb3-8" title="8">        <span class="kw">if</span> nums[fastIndex] == <span class="dv">0</span> &amp;&amp; !flag {</a>
<a class="sourceLine" id="cb3-9" title="9">            slowIndex = fastIndex</a>
<a class="sourceLine" id="cb3-10" title="10">            flag = <span class="ot">true</span></a>
<a class="sourceLine" id="cb3-11" title="11">        }</a>
<a class="sourceLine" id="cb3-12" title="12">        <span class="co">//找到之后跟后面非0得数进行对调</span></a>
<a class="sourceLine" id="cb3-13" title="13">        <span class="kw">if</span> nums[fastIndex] != <span class="dv">0</span> &amp;&amp; flag {</a>
<a class="sourceLine" id="cb3-14" title="14">            nums[slowIndex], nums[fastIndex] = nums[fastIndex], nums[slowIndex]</a>
<a class="sourceLine" id="cb3-15" title="15">            slowIndex++</a>
<a class="sourceLine" id="cb3-16" title="16">        }</a>
<a class="sourceLine" id="cb3-17" title="17">    }</a>
<a class="sourceLine" id="cb3-18" title="18">}</a></code></pre></div>
<blockquote>
<p>执行用时：28 ms，在所有 Go 提交中击败了 15.79% 的用户 内存消耗： 6.5 MB，在所有 Go 提交中击败了 97.59%的用户</p>
</blockquote>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">func</span> moveZeroes(nums []<span class="dt">int</span>) {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="kw">var</span> slowIndex <span class="dt">int</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">for</span> k, v := <span class="kw">range</span> nums {</a>
<a class="sourceLine" id="cb4-4" title="4">        <span class="kw">if</span> v == <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb4-5" title="5">            slowIndex = k</a>
<a class="sourceLine" id="cb4-6" title="6">            <span class="kw">break</span></a>
<a class="sourceLine" id="cb4-7" title="7">        }</a>
<a class="sourceLine" id="cb4-8" title="8">    }</a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="kw">for</span> fastIndex := slowIndex; fastIndex &lt; <span class="bu">len</span>(nums); fastIndex++ {</a>
<a class="sourceLine" id="cb4-10" title="10">        <span class="kw">if</span> nums[fastIndex] != <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb4-11" title="11">            nums[slowIndex], nums[fastIndex] = nums[fastIndex], nums[slowIndex]</a>
<a class="sourceLine" id="cb4-12" title="12">            slowIndex++</a>
<a class="sourceLine" id="cb4-13" title="13">        }</a>
<a class="sourceLine" id="cb4-14" title="14">    }</a>
<a class="sourceLine" id="cb4-15" title="15">}</a></code></pre></div>]]></description>
    <pubDate>Fri, 26 Aug 2022 11:11:38 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ x的平方根]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/array/0069.sqrtx</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/array/0069.sqrtx</guid>
    <description><![CDATA[<h2 id="x的平方根">x的平方根</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/sqrtx/">https://leetcode.cn/problems/sqrtx/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给你一个非负整数 x ，计算并返回x的 算术平方根 。</p>
<p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p>
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：x = 4
输出：2</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。</code></pre>
<h2 id="解题思路">解题思路</h2>
<blockquote>
<p><a href="https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/10628618#%E7%AE%97%E6%B3%95%E8%A6%81%E6%B1%82">二分查找条件</a>：顺序存储结构、关键字按大小顺序排列</p>
</blockquote>
<ul>
<li>二分查找，整数的的算术平方根必然在[0,x]之间，除1外，当两者相差大于1才能往中间去值计算平方才能与x进行比较，否则返回左边的值(小数取整)，在循环内部则可以理解成左右均为<a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF">开区间</a>，不满足条件则分别将mid赋值给left或者right，如果正好有算术平方根则返回</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">func</span> mySqrt(x <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="kw">if</span> x == <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb3-3" title="3">        <span class="kw">return</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-4" title="4">    }</a>
<a class="sourceLine" id="cb3-5" title="5">    left, right := <span class="dv">0</span>, x</a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="kw">for</span> right-left &gt; <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb3-7" title="7">        mid := left + (right-left)/<span class="dv">2</span></a>
<a class="sourceLine" id="cb3-8" title="8">        <span class="kw">if</span> mid*mid &gt; x {</a>
<a class="sourceLine" id="cb3-9" title="9">            right = mid</a>
<a class="sourceLine" id="cb3-10" title="10">        } <span class="kw">else</span> <span class="kw">if</span> mid*mid &lt; x {</a>
<a class="sourceLine" id="cb3-11" title="11">            left = mid</a>
<a class="sourceLine" id="cb3-12" title="12">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb3-13" title="13">            <span class="kw">return</span> mid</a>
<a class="sourceLine" id="cb3-14" title="14">        }</a>
<a class="sourceLine" id="cb3-15" title="15">    }</a>
<a class="sourceLine" id="cb3-16" title="16">    <span class="kw">return</span> left</a>
<a class="sourceLine" id="cb3-17" title="17">}</a></code></pre></div>
<ul>
<li>二分查找，典型的<a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF">左闭右开</a>，条件<code>l&lt;r</code></li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">func</span> mySqrt(x <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb4-2" title="2">    l, r := <span class="dv">0</span>, x</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">for</span> l &lt; r {</a>
<a class="sourceLine" id="cb4-4" title="4">        mid := (l + r + <span class="dv">1</span>) / <span class="dv">2</span></a>
<a class="sourceLine" id="cb4-5" title="5">        <span class="kw">if</span> mid*mid &gt; x {</a>
<a class="sourceLine" id="cb4-6" title="6">            r = mid - <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-7" title="7">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb4-8" title="8">            l = mid</a>
<a class="sourceLine" id="cb4-9" title="9">        }</a>
<a class="sourceLine" id="cb4-10" title="10">    }</a>
<a class="sourceLine" id="cb4-11" title="11">    <span class="kw">return</span> l</a>
<a class="sourceLine" id="cb4-12" title="12">}</a></code></pre></div>
<ul>
<li>牛顿迭代法, <a href="https://en.wikipedia.org/wiki/Integer_square_root">https://en.wikipedia.org/wiki/Integer_square_root</a>，求根号 x，即求满足 x^2 - n = 0 方程的所有解。 &gt; 执行用时： 4 ms，在所有 Go 提交中击败了 43.85% 的用户 内存消耗： 2 MB，在所有 Go 提交中击败了 99.83% 的用户</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">func</span> mySqrt(x <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb5-2" title="2">    r := x</a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="kw">for</span> r*r &gt; x {</a>
<a class="sourceLine" id="cb5-4" title="4">        r = (r + x/r) / <span class="dv">2</span></a>
<a class="sourceLine" id="cb5-5" title="5">    }</a>
<a class="sourceLine" id="cb5-6" title="6">    <span class="kw">return</span> r</a>
<a class="sourceLine" id="cb5-7" title="7">}</a></code></pre></div>]]></description>
    <pubDate>Fri, 26 Aug 2022 11:11:38 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 在排序数组中查找元素的第一个和最后一个位置]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/array/0034.find-first-and-last-position-of-element-in-sorted-array</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/array/0034.find-first-and-last-position-of-element-in-sorted-array</guid>
    <description><![CDATA[<h2 id="在排序数组中查找元素的第一个和最后一个位置">在排序数组中查找元素的第一个和最后一个位置</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回[-1, -1]。</p>
<p>你必须设计并实现时间复杂度为O(log n)的算法解决此问题。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]</code></pre>
<p>示例 3：</p>
<pre><code>输入：nums = [], target = 0
输出：[-1,-1]</code></pre>
<h2 id="解题思路">解题思路</h2>
<ul>
<li>分为三种情况：1. 数组范围外，2. 数组范围内且存在，3. 数组范围内且不存在。先判断是否在数组外，如果在随后使用二分法，根据题意使用左闭右闭的方式(即<code>left&lt;=right</code>)，在mid==target的条件下往左查找开始位置，往右查找结束位置，注意数组边界；如果始终不满足mid==target条件，则返回[-1,-1]</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">func</span> searchRange(nums []<span class="dt">int</span>, target <span class="dt">int</span>) []<span class="dt">int</span> {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="co">//1. 在数组外</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">if</span> <span class="bu">len</span>(nums) == <span class="dv">0</span> || nums[<span class="dv">0</span>] &gt; target || nums[<span class="bu">len</span>(nums)-<span class="dv">1</span>] &lt; target {</a>
<a class="sourceLine" id="cb4-4" title="4">        <span class="kw">return</span> []<span class="dt">int</span>{-<span class="dv">1</span>, <span class="dv">-1</span>}</a>
<a class="sourceLine" id="cb4-5" title="5">    }</a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="co">//2. 在数组内</span></a>
<a class="sourceLine" id="cb4-7" title="7">    left, right := <span class="dv">0</span>, <span class="bu">len</span>(nums)-<span class="dv">1</span></a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="kw">var</span> ret []<span class="dt">int</span></a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="kw">for</span> left &lt;= right {</a>
<a class="sourceLine" id="cb4-10" title="10">        mid := left + (right-left)/<span class="dv">2</span></a>
<a class="sourceLine" id="cb4-11" title="11">        <span class="kw">if</span> nums[mid] &lt; target {</a>
<a class="sourceLine" id="cb4-12" title="12">            left = mid + <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-13" title="13">        } <span class="kw">else</span> <span class="kw">if</span> nums[mid] &gt; target {</a>
<a class="sourceLine" id="cb4-14" title="14">            right = mid - <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-15" title="15">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb4-16" title="16">            <span class="co">//2.1 在数组范围内且存在</span></a>
<a class="sourceLine" id="cb4-17" title="17">            mid2 := mid</a>
<a class="sourceLine" id="cb4-18" title="18">            <span class="kw">for</span> mid<span class="dv">-1</span> &gt;= <span class="dv">0</span> &amp;&amp; nums[mid<span class="dv">-1</span>] == target {</a>
<a class="sourceLine" id="cb4-19" title="19">                mid--</a>
<a class="sourceLine" id="cb4-20" title="20">            }</a>
<a class="sourceLine" id="cb4-21" title="21">            ret = <span class="bu">append</span>(ret, mid)</a>
<a class="sourceLine" id="cb4-22" title="22">            <span class="kw">for</span> mid2+<span class="dv">1</span> &lt;= <span class="bu">len</span>(nums)-<span class="dv">1</span> &amp;&amp; nums[mid2+<span class="dv">1</span>] == target {</a>
<a class="sourceLine" id="cb4-23" title="23">                mid2++</a>
<a class="sourceLine" id="cb4-24" title="24">            }</a>
<a class="sourceLine" id="cb4-25" title="25">            ret = <span class="bu">append</span>(ret, mid2)</a>
<a class="sourceLine" id="cb4-26" title="26">            <span class="kw">return</span> ret</a>
<a class="sourceLine" id="cb4-27" title="27">        }</a>
<a class="sourceLine" id="cb4-28" title="28">    }</a>
<a class="sourceLine" id="cb4-29" title="29">    <span class="co">//2.2 在数组范围内且不存在</span></a>
<a class="sourceLine" id="cb4-30" title="30">    <span class="kw">return</span> []<span class="dt">int</span>{-<span class="dv">1</span>, <span class="dv">-1</span>}</a>
<a class="sourceLine" id="cb4-31" title="31">}</a></code></pre></div>
<ul>
<li>来自<a href="https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0034.Find-First-and-Last-Position-of-Element-in-Sorted-Array/">LeetCodeCookBook</a> 也是从三种情况入手，不过处理方式是分别处理开始位置和结束位置</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">func</span> searchRange(nums []<span class="dt">int</span>, target <span class="dt">int</span>) []<span class="dt">int</span> {</a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="kw">return</span> []<span class="dt">int</span>{searchFirstEqualElement(nums, target), searchLastEqualElement(nums, target)}</a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4">}</a>
<a class="sourceLine" id="cb5-5" title="5"></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="co">// 二分查找第一个与 target 相等的元素，时间复杂度 O(logn)</span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="kw">func</span> searchFirstEqualElement(nums []<span class="dt">int</span>, target <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb5-8" title="8">    low, high := <span class="dv">0</span>, <span class="bu">len</span>(nums)-<span class="dv">1</span></a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="kw">for</span> low &lt;= high {</a>
<a class="sourceLine" id="cb5-10" title="10">        mid := low + ((high - low) &gt;&gt; <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb5-11" title="11">        <span class="kw">if</span> nums[mid] &gt; target {</a>
<a class="sourceLine" id="cb5-12" title="12">            high = mid - <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-13" title="13">        } <span class="kw">else</span> <span class="kw">if</span> nums[mid] &lt; target {</a>
<a class="sourceLine" id="cb5-14" title="14">            low = mid + <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-15" title="15">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb5-16" title="16">            <span class="kw">if</span> (mid == <span class="dv">0</span>) || (nums[mid<span class="dv">-1</span>] != target) { <span class="co">// 找到第一个与 target 相等的元素</span></a>
<a class="sourceLine" id="cb5-17" title="17">                <span class="kw">return</span> mid</a>
<a class="sourceLine" id="cb5-18" title="18">            }</a>
<a class="sourceLine" id="cb5-19" title="19">            high = mid - <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-20" title="20">        }</a>
<a class="sourceLine" id="cb5-21" title="21">    }</a>
<a class="sourceLine" id="cb5-22" title="22">    <span class="kw">return</span> <span class="dv">-1</span></a>
<a class="sourceLine" id="cb5-23" title="23">}</a>
<a class="sourceLine" id="cb5-24" title="24"></a>
<a class="sourceLine" id="cb5-25" title="25"><span class="co">// 二分查找最后一个与 target 相等的元素，时间复杂度 O(logn)</span></a>
<a class="sourceLine" id="cb5-26" title="26"><span class="kw">func</span> searchLastEqualElement(nums []<span class="dt">int</span>, target <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb5-27" title="27">    low, high := <span class="dv">0</span>, <span class="bu">len</span>(nums)-<span class="dv">1</span></a>
<a class="sourceLine" id="cb5-28" title="28">    <span class="kw">for</span> low &lt;= high {</a>
<a class="sourceLine" id="cb5-29" title="29">        mid := low + ((high - low) &gt;&gt; <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb5-30" title="30">        <span class="kw">if</span> nums[mid] &gt; target {</a>
<a class="sourceLine" id="cb5-31" title="31">            high = mid - <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-32" title="32">        } <span class="kw">else</span> <span class="kw">if</span> nums[mid] &lt; target {</a>
<a class="sourceLine" id="cb5-33" title="33">            low = mid + <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-34" title="34">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb5-35" title="35">            <span class="kw">if</span> (mid == <span class="bu">len</span>(nums)-<span class="dv">1</span>) || (nums[mid+<span class="dv">1</span>] != target) { <span class="co">// 找到最后一个与 target 相等的元素</span></a>
<a class="sourceLine" id="cb5-36" title="36">                <span class="kw">return</span> mid</a>
<a class="sourceLine" id="cb5-37" title="37">            }</a>
<a class="sourceLine" id="cb5-38" title="38">            low = mid + <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-39" title="39">        }</a>
<a class="sourceLine" id="cb5-40" title="40">    }</a>
<a class="sourceLine" id="cb5-41" title="41">    <span class="kw">return</span> <span class="dv">-1</span></a>
<a class="sourceLine" id="cb5-42" title="42">}</a></code></pre></div>]]></description>
    <pubDate>Fri, 26 Aug 2022 11:11:38 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 下一个排列]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/array/0031.next-permutation</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/array/0031.next-permutation</guid>
    <description><![CDATA[<h2 id="下一个排列">下一个排列</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/next-permutation/">https://leetcode.cn/problems/next-permutation/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。</p>
<p>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<p>例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。 给你一个整数数组 nums ，找出 nums 的下一个排列。</p>
<p>必须 原地 修改，只允许使用额外常数空间。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：nums = [1,2,3]
输出：[1,3,2]</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：nums = [3,2,1]
输出：[1,2,3]</code></pre>
<p>示例 3：</p>
<pre class="text"><code>输入：nums = [1,1,5]
输出：[1,5,1]</code></pre>
<p>提示： - 1 &lt;= nums.length &lt;= 100 - 0 &lt;= nums[i] &lt;= 100</p>
<h2 id="解题思路">解题思路</h2>
<figure>
<img src="https://code-thinking.cdn.bcebos.com/pics/31.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97.png" alt="解释" /><figcaption>解释</figcaption>
</figure>
<ul>
<li>理解：把数组本身看作一个数，就是一个数的从小到大的排列，随后对找出这个数在排列中后一位比他大的数，边界情况则找到最小数。</li>
<li>常规情况：倒序遍历数组，找到第一个降序的部分，中间的值暂且称为山峰，随后将山峰两侧的值进行交换，最后在对山峰到数组末尾的值进行排序</li>
<li>边界情况：本身就是最大，直接倒序即可</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">func</span> nextPermutation(nums []<span class="dt">int</span>)  {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="kw">for</span> i := <span class="bu">len</span>(nums) - <span class="dv">1</span>; i &gt;= <span class="dv">0</span>; i-- {</a>
<a class="sourceLine" id="cb4-3" title="3">        <span class="kw">for</span> j := <span class="bu">len</span>(nums) - <span class="dv">1</span>; j &gt; i; j-- {</a>
<a class="sourceLine" id="cb4-4" title="4">            <span class="kw">if</span> nums[j] &gt; nums[i] {</a>
<a class="sourceLine" id="cb4-5" title="5">                nums[i], nums[j] = nums[j], nums[i]</a>
<a class="sourceLine" id="cb4-6" title="6">                sort.Ints(nums[i+<span class="dv">1</span>:])</a>
<a class="sourceLine" id="cb4-7" title="7">                <span class="kw">return</span></a>
<a class="sourceLine" id="cb4-8" title="8">            }</a>
<a class="sourceLine" id="cb4-9" title="9">        }</a>
<a class="sourceLine" id="cb4-10" title="10">    }</a>
<a class="sourceLine" id="cb4-11" title="11">    <span class="co">//最大，直接排序即可</span></a>
<a class="sourceLine" id="cb4-12" title="12">    sort.Ints(nums)</a>
<a class="sourceLine" id="cb4-13" title="13">}</a></code></pre></div>]]></description>
    <pubDate>Fri, 26 Aug 2022 11:11:38 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 移除元素]]></title>
    <link>https://pages.zsong.ml/leetcode-doc/#/docs/array/0027.remove-element</link>
    <guid isPermaLink="false">https://pages.zsong.ml/leetcode-doc/#/docs/array/0027.remove-element</guid>
    <description><![CDATA[<h2 id="移除元素">移除元素</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/remove-element/">https://leetcode.cn/problems/remove-element/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给你一个数组 nums和一个值 val，你需要 原地 移除所有数值等于val的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<pre class="text"><code>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}</code></pre>
<p>示例 1：</p>
<pre class="text"><code>输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</code></pre>
<h2 id="解题思路">解题思路</h2>
<blockquote>
<p><a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#%E6%80%9D%E8%B7%AF">代码随想录-双指针</a></p>
</blockquote>
<ul>
<li>双指针：首先明白，去除元素本质上就是移动元素。快慢指针方式，快指针寻找就数组元素，慢指针更新新数组，如果快指针指向元素不等于需要去除元素，则将快指针元素赋给慢指针指向元素，慢指针右移，否则快指针右移，慢指针不动，如此往复即可得到满足条件新数组，长度则为慢指针指向元素下标值</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">func</span> removeElement(nums []<span class="dt">int</span>, val <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="kw">var</span> slowIndex <span class="dt">int</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">for</span> fastIndex := <span class="dv">0</span>; fastIndex &lt; <span class="bu">len</span>(nums); fastIndex++ {</a>
<a class="sourceLine" id="cb4-4" title="4">        <span class="kw">if</span> nums[fastIndex] != val {</a>
<a class="sourceLine" id="cb4-5" title="5">            nums[slowIndex] = nums[fastIndex]</a>
<a class="sourceLine" id="cb4-6" title="6">            slowIndex++</a>
<a class="sourceLine" id="cb4-7" title="7">        }</a>
<a class="sourceLine" id="cb4-8" title="8">    }</a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="kw">return</span> slowIndex</a>
<a class="sourceLine" id="cb4-10" title="10">}</a></code></pre></div>]]></description>
    <pubDate>Fri, 26 Aug 2022 11:11:38 +0800</pubDate>
  </item>
  
</channel>
</rss>
