<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
<channel>
  <title>LeetCode刷题记录</title>
  <atom:link href="https://scanas.ml/leetcode-doc/feed.xml" rel="self" type="application/rss+xml" />
  <link>https://scanas.ml/leetcode-doc</link>
  <description>LeetCode刷题记录</description>
   
  <item>
    <title><![CDATA[ [题目说明](https://leetcode.cn/problems/binary-search/)]]></title>
    <link>https://scanas.ml/leetcode-doc/#/docs/array/704.binary-search</link>
    <guid isPermaLink="false">https://scanas.ml/leetcode-doc/#/docs/array/704.binary-search</guid>
    <description><![CDATA[<h2 id="题目说明"><a href="https://leetcode.cn/problems/binary-search/">题目说明</a></h2>
<p>给定一个n个元素有序的（升序）整型数组nums 和一个目标值target ，写一个函数搜索nums中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>示例 1：</p>
<pre class="text"><code>输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1</code></pre>
<p>提示：</p>
<ul>
<li>你可以假设 nums 中的所有元素是不重复的。</li>
<li>n 将在 [1, 10000]之间。</li>
<li>nums 的每个元素都将在 [-9999, 9999]之间。</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<ul>
<li><p>二分法主要关注循环条件，以及循环里判断后，针对中间值的处理过程，闭区间与开区间需要区分</p></li>
<li>左闭右闭</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">func</span> search(nums []<span class="dt">int</span>, target <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb3-2" title="2">    begin, end, mid := <span class="dv">0</span>, <span class="bu">len</span>(nums)-<span class="dv">1</span>, (<span class="bu">len</span>(nums)-<span class="dv">1</span>)/<span class="dv">2</span></a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="co">//左闭右闭</span></a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="kw">for</span> begin &lt;= end {</a>
<a class="sourceLine" id="cb3-5" title="5">        <span class="kw">if</span> target &lt; nums[mid] {</a>
<a class="sourceLine" id="cb3-6" title="6">            end = mid - <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-7" title="7">        } <span class="kw">else</span> <span class="kw">if</span> target &gt; nums[mid] {</a>
<a class="sourceLine" id="cb3-8" title="8">            begin = mid + <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-9" title="9">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb3-10" title="10">            <span class="kw">return</span> mid</a>
<a class="sourceLine" id="cb3-11" title="11">        }</a>
<a class="sourceLine" id="cb3-12" title="12">        mid = (begin + end) / <span class="dv">2</span></a>
<a class="sourceLine" id="cb3-13" title="13">        <span class="co">//begin和end为int，避免越界可以写成</span></a>
<a class="sourceLine" id="cb3-14" title="14">        <span class="co">//mid = begin + (end - begin) / 2</span></a>
<a class="sourceLine" id="cb3-15" title="15">    }</a>
<a class="sourceLine" id="cb3-16" title="16">    <span class="kw">return</span> <span class="dv">-1</span></a>
<a class="sourceLine" id="cb3-17" title="17">}</a></code></pre></div>
<ul>
<li>左闭右开</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">func</span> search(nums []<span class="dt">int</span>, target <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb4-2" title="2">    left, right := <span class="dv">0</span>, <span class="bu">len</span>(nums)-<span class="dv">1</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">for</span> left &lt; right {</a>
<a class="sourceLine" id="cb4-4" title="4">        mid := left + (right-left)/<span class="dv">2</span></a>
<a class="sourceLine" id="cb4-5" title="5">        <span class="kw">if</span> nums[mid] &gt; target {</a>
<a class="sourceLine" id="cb4-6" title="6">            right = mid</a>
<a class="sourceLine" id="cb4-7" title="7">        } <span class="kw">else</span> <span class="kw">if</span> nums[mid] &lt; target {</a>
<a class="sourceLine" id="cb4-8" title="8">            left = mid + <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-9" title="9">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb4-10" title="10">            <span class="kw">return</span> mid</a>
<a class="sourceLine" id="cb4-11" title="11">        }</a>
<a class="sourceLine" id="cb4-12" title="12">    }</a>
<a class="sourceLine" id="cb4-13" title="13">    <span class="kw">return</span> <span class="dv">-1</span></a>
<a class="sourceLine" id="cb4-14" title="14">}</a></code></pre></div>]]></description>
    <pubDate>Wed, 17 Aug 2022 16:31:31 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[开始]]></title>
    <link>https://scanas.ml/leetcode-doc/#/_sidebar</link>
    <guid isPermaLink="false">https://scanas.ml/leetcode-doc/#/_sidebar</guid>
    <description><![CDATA[<ul>
<li>开始
<ul>
<li><a href="README.md">说明</a></li>
</ul></li>
<li>数组
<ul>
<li><a href="docs/array/0001.two-sum.md">1. 两数之和 (简单)</a></li>
<li><a href="docs/array/0011.container-with-most-water.md">11. 盛最多水的容器 (中等)</a></li>
<li><a href="docs/array/0015.3sum.md">15. 三数之和 (中等)</a></li>
<li><a href="docs/array/0016.3sum-closest.md">16. 最接近的三数之和 (中等)</a></li>
<li><a href="docs/array/0018.4sum.md">18. 四数之和 (中等)</a></li>
<li><a href="docs/array/0031.next-permutation.md">31. 下一个排列 (中等)</a></li>
<li><a href="docs/array/0088.merge-sorted-array.md">88. 合并两个有序数组 (简单)</a></li>
<li><a href="docs/array/0118.pascals-triangle.md">118. 杨辉三角 (简单)</a></li>
<li><a href="docs/array/0119.pascals-triangle-ii.md">119. 杨辉三角 II (简单)</a></li>
<li><a href="docs/array/0121.best-time-to-buy-and-sell-stock.md">121. 买卖股票的最佳时机 (简单)</a></li>
<li><a href="docs/array/0136.single-number.md">136. 只出现一次的数字 (简单)</a></li>
<li><a href="docs/array/704.binary-search.md">704. 二分查找 (简单)</a></li>
<li><a href="docs/array/1403.minimum-subsequence-in-non-increasing-order.md">1403. 非递增顺序的最小子序列 (简单)</a></li>
</ul></li>
<li>字符串
<ul>
<li><a href="docs/string/1408.string-matching-in-an-array.md">1408. 数组中的字符串匹配 (简单)</a></li>
<li><a href="docs/string/1417.reformat-the-string.md">1417. 重新格式化字符串 (简单)</a></li>
</ul></li>
<li>链表
<ul>
<li><a href="docs/linkedList/0002.add-two-numbers.md">2. 两数相加 (中等)</a></li>
</ul></li>
</ul>]]></description>
    <pubDate>Wed, 17 Aug 2022 16:31:31 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ [题目说明](https://leetcode.cn/problems/next-permutation/)]]></title>
    <link>https://scanas.ml/leetcode-doc/#/docs/array/0031.next-permutation</link>
    <guid isPermaLink="false">https://scanas.ml/leetcode-doc/#/docs/array/0031.next-permutation</guid>
    <description><![CDATA[<h2 id="题目说明"><a href="https://leetcode.cn/problems/next-permutation/">题目说明</a></h2>
<p>整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。</p>
<p>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<p>例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。 给你一个整数数组 nums ，找出 nums 的下一个排列。</p>
<p>必须 原地 修改，只允许使用额外常数空间。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：nums = [1,2,3]
输出：[1,3,2]</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：nums = [3,2,1]
输出：[1,2,3]</code></pre>
<p>示例 3：</p>
<pre class="text"><code>输入：nums = [1,1,5]
输出：[1,5,1]</code></pre>
<p>提示： - 1 &lt;= nums.length &lt;= 100 - 0 &lt;= nums[i] &lt;= 100</p>
<h2 id="解题思路">解题思路</h2>
<figure>
<img src="https://code-thinking.cdn.bcebos.com/pics/31.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97.png" alt="解释" /><figcaption>解释</figcaption>
</figure>
<ul>
<li>理解：把数组本身看作一个数，就是一个数的从小到大的排列，随后对找出这个数在排列中后一位比他大的数，边界情况则找到最小数。</li>
<li>常规情况：倒序遍历数组，找到第一个降序的部分，中间的值暂且称为山峰，随后将山峰两侧的值进行交换，最后在对山峰到数组末尾的值进行排序</li>
<li>边界情况：本身就是最大，直接倒序即可 &gt; 执行用时： 4 ms，在所有 Go 提交中击败了 14.39% 的用户 内存消耗：2.3 MB，在所有 Go 提交中击败了 18.50% 的用户</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">func</span> nextPermutation(nums []<span class="dt">int</span>)  {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="kw">for</span> i := <span class="bu">len</span>(nums) - <span class="dv">1</span>; i &gt;= <span class="dv">0</span>; i-- {</a>
<a class="sourceLine" id="cb4-3" title="3">        <span class="kw">for</span> j := <span class="bu">len</span>(nums) - <span class="dv">1</span>; j &gt; i; j-- {</a>
<a class="sourceLine" id="cb4-4" title="4">            <span class="kw">if</span> nums[j] &gt; nums[i] {</a>
<a class="sourceLine" id="cb4-5" title="5">                nums[i], nums[j] = nums[j], nums[i]</a>
<a class="sourceLine" id="cb4-6" title="6">                sort.Ints(nums[i+<span class="dv">1</span>:])</a>
<a class="sourceLine" id="cb4-7" title="7">                <span class="kw">return</span></a>
<a class="sourceLine" id="cb4-8" title="8">            }</a>
<a class="sourceLine" id="cb4-9" title="9">        }</a>
<a class="sourceLine" id="cb4-10" title="10">    }</a>
<a class="sourceLine" id="cb4-11" title="11">    <span class="co">//最大，直接排序即可</span></a>
<a class="sourceLine" id="cb4-12" title="12">    sort.Ints(nums)</a>
<a class="sourceLine" id="cb4-13" title="13">}</a></code></pre></div>]]></description>
    <pubDate>Mon, 15 Aug 2022 16:23:05 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ [题目说明](https://leetcode.cn/problems/4sum/)]]></title>
    <link>https://scanas.ml/leetcode-doc/#/docs/array/0018.4sum</link>
    <guid isPermaLink="false">https://scanas.ml/leetcode-doc/#/docs/array/0018.4sum</guid>
    <description><![CDATA[<h2 id="题目说明"><a href="https://leetcode.cn/problems/4sum/">题目说明</a></h2>
<p>给你一个由 n 个整数组成的数组nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组[nums[a], nums[b], nums[c], nums[d]（若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<p>0 &lt;= a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]</code></pre>
<h2 id="解题思路">解题思路</h2>
<ul>
<li>本质上和第三题思路一致：排序+双指针，只是说，需要再加一层，然后操作双指针来取出结果
<ol type="1">
<li>最外层循环注意减少耗时的第一个数与target的比较，不再是0，负数的话，多个负数之和越来越小。</li>
<li>此外层依旧需要对最开始的数进行去重，防止出现重复结果，不过注意初始值的下标：<code>j&gt;i+1</code>。 &gt; 执行用时： 8 ms，在所有Go 提交中击败了 77.31% 的用户内存消耗：2.6 MB，在所有 Go提交中击败了 75.89% 的用户</li>
</ol></li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">func</span> fourSum(nums []<span class="dt">int</span>, target <span class="dt">int</span>) [][]<span class="dt">int</span> {</a>
<a class="sourceLine" id="cb3-2" title="2">    sort.Ints(nums)</a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="kw">var</span> ret [][]<span class="dt">int</span></a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="bu">len</span>(nums)-<span class="dv">3</span>; i++ {</a>
<a class="sourceLine" id="cb3-5" title="5">        <span class="co">//去除此种状态，不能跟第三题一样，不是与0相比，多个负数相加会得到更小的值</span></a>
<a class="sourceLine" id="cb3-6" title="6">        <span class="co">//if i == 0 &amp;&amp; nums[i] &gt; target {</span></a>
<a class="sourceLine" id="cb3-7" title="7">        <span class="co">//  break</span></a>
<a class="sourceLine" id="cb3-8" title="8">        <span class="co">//}</span></a>
<a class="sourceLine" id="cb3-9" title="9">        <span class="co">//起始值去重</span></a>
<a class="sourceLine" id="cb3-10" title="10">        <span class="kw">if</span> i &gt; <span class="dv">0</span> &amp;&amp; nums[i] == nums[i<span class="dv">-1</span>] {</a>
<a class="sourceLine" id="cb3-11" title="11">            <span class="kw">continue</span></a>
<a class="sourceLine" id="cb3-12" title="12">        }</a>
<a class="sourceLine" id="cb3-13" title="13">        <span class="kw">for</span> j := i + <span class="dv">1</span>; j &lt; <span class="bu">len</span>(nums)-<span class="dv">2</span>; j++ {</a>
<a class="sourceLine" id="cb3-14" title="14">            <span class="co">//起始值去重</span></a>
<a class="sourceLine" id="cb3-15" title="15">            <span class="kw">if</span> j &gt; i+<span class="dv">1</span> &amp;&amp; nums[j] == nums[j<span class="dv">-1</span>] {</a>
<a class="sourceLine" id="cb3-16" title="16">                <span class="kw">continue</span></a>
<a class="sourceLine" id="cb3-17" title="17">            }</a>
<a class="sourceLine" id="cb3-18" title="18">            l, r := j+<span class="dv">1</span>, <span class="bu">len</span>(nums)-<span class="dv">1</span></a>
<a class="sourceLine" id="cb3-19" title="19">            <span class="kw">for</span> l &lt; r {</a>
<a class="sourceLine" id="cb3-20" title="20">                sum := nums[i] + nums[j] + nums[l] + nums[r]</a>
<a class="sourceLine" id="cb3-21" title="21">                <span class="kw">if</span> sum == target {</a>
<a class="sourceLine" id="cb3-22" title="22">                    ret = <span class="bu">append</span>(ret, []<span class="dt">int</span>{nums[i], nums[j], nums[l], nums[r]})</a>
<a class="sourceLine" id="cb3-23" title="23">                    <span class="kw">for</span> l &lt; r &amp;&amp; nums[l] == nums[l+<span class="dv">1</span>] {</a>
<a class="sourceLine" id="cb3-24" title="24">                        l++</a>
<a class="sourceLine" id="cb3-25" title="25">                    }</a>
<a class="sourceLine" id="cb3-26" title="26">                    <span class="kw">for</span> l &lt; r &amp;&amp; nums[r] == nums[r<span class="dv">-1</span>] {</a>
<a class="sourceLine" id="cb3-27" title="27">                        r--</a>
<a class="sourceLine" id="cb3-28" title="28">                    }</a>
<a class="sourceLine" id="cb3-29" title="29">                    l++</a>
<a class="sourceLine" id="cb3-30" title="30">                    r--</a>
<a class="sourceLine" id="cb3-31" title="31">                } <span class="kw">else</span> <span class="kw">if</span> sum &gt; target {</a>
<a class="sourceLine" id="cb3-32" title="32">                    r--</a>
<a class="sourceLine" id="cb3-33" title="33">                } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb3-34" title="34">                    l++</a>
<a class="sourceLine" id="cb3-35" title="35">                }</a>
<a class="sourceLine" id="cb3-36" title="36">            }</a>
<a class="sourceLine" id="cb3-37" title="37">        }</a>
<a class="sourceLine" id="cb3-38" title="38">    }</a>
<a class="sourceLine" id="cb3-39" title="39">    <span class="kw">return</span> ret</a>
<a class="sourceLine" id="cb3-40" title="40">}</a></code></pre></div>]]></description>
    <pubDate>Fri, 12 Aug 2022 14:10:53 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[说明]]></title>
    <link>https://scanas.ml/leetcode-doc/#/README</link>
    <guid isPermaLink="false">https://scanas.ml/leetcode-doc/#/README</guid>
    <description><![CDATA[<h1 id="说明">说明</h1>
<p>leetcode刷题记录, 个人博客 <a href="//www.zggsong.cn">zggsong.cn</a>, wiki <a href="//wiki.zggsong.cn">wiki.zggsong.cn</a></p>]]></description>
    <pubDate>Thu, 11 Aug 2022 15:37:24 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ [题目说明](https://leetcode.cn/problems/reformat-the-string/)]]></title>
    <link>https://scanas.ml/leetcode-doc/#/docs/string/1417.reformat-the-string</link>
    <guid isPermaLink="false">https://scanas.ml/leetcode-doc/#/docs/string/1417.reformat-the-string</guid>
    <description><![CDATA[<h2 id="题目说明"><a href="https://leetcode.cn/problems/reformat-the-string/">题目说明</a></h2>
<p>给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。</p>
<p>请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。</p>
<p>请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：s = &quot;a0b1c2&quot;
输出：&quot;0a1b2c&quot;
解释：&quot;0a1b2c&quot; 中任意两个相邻字符的类型都不同。 &quot;a0b1c2&quot;, &quot;0a1b2c&quot;, &quot;0c2a1b&quot; 也是满足题目要求的答案。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：s = &quot;leetcode&quot;
输出：&quot;&quot;
解释：&quot;leetcode&quot; 中只有字母，所以无法满足重新格式化的条件。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：s = &quot;leetcode&quot;
输出：&quot;&quot;
解释：&quot;leetcode&quot; 中只有字母，所以无法满足重新格式化的条件。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：s = &quot;leetcode&quot;
输出：&quot;&quot;
解释：&quot;leetcode&quot; 中只有字母，所以无法满足重新格式化的条件。</code></pre>
<p>示例 3：</p>
<pre class="text"><code>输入：s = &quot;1229857369&quot;
输出：&quot;&quot;
解释：&quot;1229857369&quot; 中只有数字，所以无法满足重新格式化的条件。</code></pre>
<p>示例 4：</p>
<pre class="text"><code>输入：s = &quot;covid2019&quot;
输出：&quot;c2o0v1i9d&quot;输入：s = &quot;covid2019&quot;
输出：&quot;c2o0v1i9d&quot;</code></pre>
<p>示例5：</p>
<pre class="text"><code>输入：s = &quot;ab123&quot;
输出：&quot;1a2b3&quot;</code></pre>
<h2 id="解题思路">解题思路</h2>
<ul>
<li>数组暴力解法：分割成两个数组，字符数组，数字数组，然后去除不满足的情况（两个数组长度之差超过1的则为不满足）随后判断谁大，那个先添加到字符串中，直至添加完成 &gt; 执行用时： 4 ms，在所有Go提交中击败了 22.86％ 的用户 内存消耗： 6.6 MB，在所有 Go 提交中击败了 17.14% 的用户</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">func</span> reformat(s <span class="dt">string</span>) <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb8-2" title="2">    ret, c1, c2 := <span class="st">&quot;&quot;</span>, []<span class="dt">string</span>{}, []<span class="dt">string</span>{}</a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="kw">for</span> _, v := <span class="kw">range</span> s {</a>
<a class="sourceLine" id="cb8-4" title="4">        <span class="kw">if</span> v &gt;= <span class="dv">48</span> &amp;&amp; v &lt;= <span class="dv">57</span> {</a>
<a class="sourceLine" id="cb8-5" title="5">            c1 = <span class="bu">append</span>(c1, <span class="dt">string</span>(v))</a>
<a class="sourceLine" id="cb8-6" title="6">            <span class="kw">continue</span></a>
<a class="sourceLine" id="cb8-7" title="7">        }</a>
<a class="sourceLine" id="cb8-8" title="8">        c2 = <span class="bu">append</span>(c2, <span class="dt">string</span>(v))</a>
<a class="sourceLine" id="cb8-9" title="9">    }</a>
<a class="sourceLine" id="cb8-10" title="10">    sub := <span class="bu">len</span>(c1) - <span class="bu">len</span>(c2)</a>
<a class="sourceLine" id="cb8-11" title="11">    <span class="kw">if</span> sub &lt;= <span class="dv">1</span> &amp;&amp; sub &gt;= <span class="dv">-1</span> {</a>
<a class="sourceLine" id="cb8-12" title="12">        <span class="kw">if</span> sub &lt; <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb8-13" title="13">            c1, c2 = c2, c1</a>
<a class="sourceLine" id="cb8-14" title="14">        }</a>
<a class="sourceLine" id="cb8-15" title="15">        <span class="kw">for</span> i := <span class="kw">range</span> c2 {</a>
<a class="sourceLine" id="cb8-16" title="16">            ret += c1[i] + c2[i]</a>
<a class="sourceLine" id="cb8-17" title="17">        }</a>
<a class="sourceLine" id="cb8-18" title="18">        <span class="kw">if</span> sub != <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb8-19" title="19">            ret += c1[<span class="bu">len</span>(c1)-<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb8-20" title="20">        }</a>
<a class="sourceLine" id="cb8-21" title="21">    }</a>
<a class="sourceLine" id="cb8-22" title="22">    <span class="kw">return</span> ret</a>
<a class="sourceLine" id="cb8-23" title="23">}</a></code></pre></div>
<ul>
<li>字符串暴力解法：方法同数组解法 &gt; 执行用时：8ms，在所有 Go 提交中击败了 14.29% 的用户 内存消耗：6.7 MB，在所有Go提交中击败了 11.43% 的用户</li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">func</span> reformat(s <span class="dt">string</span>) <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb9-2" title="2">    s1, s2 := <span class="st">&quot;&quot;</span>, <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="kw">for</span> _, v := <span class="kw">range</span> s {</a>
<a class="sourceLine" id="cb9-4" title="4">        <span class="kw">if</span> v &gt;= <span class="dv">48</span> &amp;&amp; v &lt;= <span class="dv">57</span> {</a>
<a class="sourceLine" id="cb9-5" title="5">            s1 += <span class="dt">string</span>(v)</a>
<a class="sourceLine" id="cb9-6" title="6">            <span class="kw">continue</span></a>
<a class="sourceLine" id="cb9-7" title="7">        }</a>
<a class="sourceLine" id="cb9-8" title="8">        s2 += <span class="dt">string</span>(v)</a>
<a class="sourceLine" id="cb9-9" title="9">    }</a>
<a class="sourceLine" id="cb9-10" title="10">    <span class="kw">if</span> <span class="bu">len</span>(s1)-<span class="bu">len</span>(s2) &lt;= <span class="dv">1</span> &amp;&amp; <span class="bu">len</span>(s1)-<span class="bu">len</span>(s2) &gt;= <span class="dv">-1</span> {</a>
<a class="sourceLine" id="cb9-11" title="11">        <span class="kw">if</span> <span class="bu">len</span>(s1) &lt; <span class="bu">len</span>(s2) {</a>
<a class="sourceLine" id="cb9-12" title="12">            s1, s2 = s2, s1</a>
<a class="sourceLine" id="cb9-13" title="13">        }</a>
<a class="sourceLine" id="cb9-14" title="14">        ret := <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb9-15" title="15">        <span class="kw">for</span> i, _ := <span class="kw">range</span> s2 {</a>
<a class="sourceLine" id="cb9-16" title="16">            ret += <span class="dt">string</span>(s1[i]) + <span class="dt">string</span>(s2[i])</a>
<a class="sourceLine" id="cb9-17" title="17">        }</a>
<a class="sourceLine" id="cb9-18" title="18">        <span class="kw">if</span> <span class="bu">len</span>(s1) != <span class="bu">len</span>(s2) {</a>
<a class="sourceLine" id="cb9-19" title="19">            ret += <span class="dt">string</span>(s1[<span class="bu">len</span>(s1)-<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb9-20" title="20">        }</a>
<a class="sourceLine" id="cb9-21" title="21">        <span class="kw">return</span> ret</a>
<a class="sourceLine" id="cb9-22" title="22">    }</a>
<a class="sourceLine" id="cb9-23" title="23">    <span class="kw">return</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb9-24" title="24">}</a></code></pre></div>]]></description>
    <pubDate>Thu, 11 Aug 2022 15:27:37 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ [题目说明](https://leetcode.cn/problems/3sum-closest/)]]></title>
    <link>https://scanas.ml/leetcode-doc/#/docs/array/0016.3sum-closest</link>
    <guid isPermaLink="false">https://scanas.ml/leetcode-doc/#/docs/array/0016.3sum-closest</guid>
    <description><![CDATA[<h2 id="题目说明"><a href="https://leetcode.cn/problems/3sum-closest/">题目说明</a></h2>
<p>给你一个长度为 n 的整数数组nums和 一个目标值target。请你从 nums 中选出三个整数，使它们的和与target最接近。</p>
<p>返回这三个数的和。</p>
<p>假定每组输入只存在恰好一个解。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：nums = [0,0,0], target = 1
输出：0</code></pre>
<ul>
<li>提示：
<ul>
<li>3 &lt;= nums.length &lt;= 1000</li>
<li>1000 &lt;= nums[i] &lt;= 1000</li>
<li>104 &lt;= target &lt;= 104</li>
</ul></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<ol type="1">
<li>类似于<a href="docs/array/0015.3sum.md">15题. 三数之和</a>，只是相应的把求解变成了求距离最近的三数之和，相应的排序，方便后续操作指针，初始化前三数之和以及与最小差值（方便看，写了一个简单的整数取绝对值的函数，返回绝对值和入参是否为正整数），随后三个指针初始化 p:=0, l:=p+1, r:=len(nums-1)，内层循环判断新的差值是否比已知最小差值更小，如果是则刷新sum和min，同理去除三元组重复值，减少计算时间，外层通过判断计算新差值的正负来移动l，r指针，完成数组遍历</li>
</ol>
<blockquote>
<p>执行用时： 56 ms, 在所有 Go 提交中击败了 56.98%的用户内存消耗：5.6 MB, 在所有 Go 提交中击败了 59.89%的用户</p>
</blockquote>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">func</span> threeSumClosest(nums []<span class="dt">int</span>, target <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb3-2" title="2">    sort.Ints(nums)</a>
<a class="sourceLine" id="cb3-3" title="3">    sum := nums[<span class="dv">0</span>] + nums[<span class="dv">1</span>] + nums[<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb3-4" title="4">    min, _ := intAbs(sum - target)</a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="kw">for</span> point := <span class="dv">0</span>; point &lt; <span class="bu">len</span>(nums)-<span class="dv">2</span>; point++ {</a>
<a class="sourceLine" id="cb3-6" title="6">        left, right := point+<span class="dv">1</span>, <span class="bu">len</span>(nums)-<span class="dv">1</span></a>
<a class="sourceLine" id="cb3-7" title="7">        <span class="kw">for</span> left &lt; right {</a>
<a class="sourceLine" id="cb3-8" title="8">            tmp, t := intAbs(nums[point] + nums[left] + nums[right] - target)</a>
<a class="sourceLine" id="cb3-9" title="9">            <span class="kw">if</span> tmp &lt; min {</a>
<a class="sourceLine" id="cb3-10" title="10">                min = tmp</a>
<a class="sourceLine" id="cb3-11" title="11">                sum = nums[point] + nums[left] + nums[right]</a>
<a class="sourceLine" id="cb3-12" title="12">                <span class="kw">for</span> left &lt; right &amp;&amp; nums[left] == nums[left+<span class="dv">1</span>] {</a>
<a class="sourceLine" id="cb3-13" title="13">                    left++</a>
<a class="sourceLine" id="cb3-14" title="14">                }</a>
<a class="sourceLine" id="cb3-15" title="15">                <span class="kw">for</span> left &lt; right &amp;&amp; nums[right] == nums[right<span class="dv">-1</span>] {</a>
<a class="sourceLine" id="cb3-16" title="16">                    right--</a>
<a class="sourceLine" id="cb3-17" title="17">                }</a>
<a class="sourceLine" id="cb3-18" title="18">            }</a>
<a class="sourceLine" id="cb3-19" title="19">            <span class="kw">if</span> t {</a>
<a class="sourceLine" id="cb3-20" title="20">                right--</a>
<a class="sourceLine" id="cb3-21" title="21">            } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb3-22" title="22">                left++</a>
<a class="sourceLine" id="cb3-23" title="23">            }</a>
<a class="sourceLine" id="cb3-24" title="24">        }</a>
<a class="sourceLine" id="cb3-25" title="25">    }</a>
<a class="sourceLine" id="cb3-26" title="26">    <span class="kw">return</span> sum</a>
<a class="sourceLine" id="cb3-27" title="27">}</a>
<a class="sourceLine" id="cb3-28" title="28"><span class="co">//</span></a>
<a class="sourceLine" id="cb3-29" title="29"><span class="co">//  intAbs</span></a>
<a class="sourceLine" id="cb3-30" title="30"><span class="co">//  @Description: 取int绝对值</span></a>
<a class="sourceLine" id="cb3-31" title="31"><span class="co">//  @param num  参数</span></a>
<a class="sourceLine" id="cb3-32" title="32"><span class="co">//  @return int 取绝对值目标值</span></a>
<a class="sourceLine" id="cb3-33" title="33"><span class="co">//  @return bool 入参是否为正整数</span></a>
<a class="sourceLine" id="cb3-34" title="34"><span class="co">//</span></a>
<a class="sourceLine" id="cb3-35" title="35"><span class="kw">func</span> intAbs(num <span class="dt">int</span>) (<span class="dt">int</span>, <span class="dt">bool</span>) {</a>
<a class="sourceLine" id="cb3-36" title="36">    <span class="kw">if</span> num &lt; <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb3-37" title="37">        <span class="kw">return</span> -num, <span class="ot">false</span></a>
<a class="sourceLine" id="cb3-38" title="38">    }</a>
<a class="sourceLine" id="cb3-39" title="39">    <span class="kw">return</span> num, <span class="ot">true</span></a>
<a class="sourceLine" id="cb3-40" title="40">}</a></code></pre></div>
<ol start="2" type="1">
<li>优化</li>
</ol>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">func</span> threeSumClosest(nums []<span class="dt">int</span>, target <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb4-2" title="2">    sort.Ints(nums)</a>
<a class="sourceLine" id="cb4-3" title="3">    closerSum := nums[<span class="dv">0</span>] + nums[<span class="dv">1</span>] + nums[<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="kw">for</span> point := <span class="dv">0</span>; point &lt; <span class="bu">len</span>(nums)-<span class="dv">2</span>; point++ {</a>
<a class="sourceLine" id="cb4-5" title="5">        left, right := point+<span class="dv">1</span>, <span class="bu">len</span>(nums)-<span class="dv">1</span></a>
<a class="sourceLine" id="cb4-6" title="6">        <span class="kw">for</span> left &lt; right {</a>
<a class="sourceLine" id="cb4-7" title="7">            threeSum := nums[point] + nums[left] + nums[right]</a>
<a class="sourceLine" id="cb4-8" title="8">            <span class="kw">if</span> intAbs(threeSum-target) &lt; intAbs(closerSum-target) {</a>
<a class="sourceLine" id="cb4-9" title="9">                closerSum = threeSum</a>
<a class="sourceLine" id="cb4-10" title="10">                <span class="kw">for</span> left &lt; right &amp;&amp; nums[left] == nums[left+<span class="dv">1</span>] {</a>
<a class="sourceLine" id="cb4-11" title="11">                    left++</a>
<a class="sourceLine" id="cb4-12" title="12">                }</a>
<a class="sourceLine" id="cb4-13" title="13">                <span class="kw">for</span> left &lt; right &amp;&amp; nums[right] == nums[right<span class="dv">-1</span>] {</a>
<a class="sourceLine" id="cb4-14" title="14">                    right--</a>
<a class="sourceLine" id="cb4-15" title="15">                }</a>
<a class="sourceLine" id="cb4-16" title="16">            }</a>
<a class="sourceLine" id="cb4-17" title="17">            <span class="kw">if</span> threeSum &gt; target {</a>
<a class="sourceLine" id="cb4-18" title="18">                right--</a>
<a class="sourceLine" id="cb4-19" title="19">            } <span class="kw">else</span> <span class="kw">if</span> threeSum &lt; target {</a>
<a class="sourceLine" id="cb4-20" title="20">                left++</a>
<a class="sourceLine" id="cb4-21" title="21">            } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb4-22" title="22">                <span class="kw">return</span> target</a>
<a class="sourceLine" id="cb4-23" title="23">            }</a>
<a class="sourceLine" id="cb4-24" title="24">        }</a>
<a class="sourceLine" id="cb4-25" title="25">    }</a>
<a class="sourceLine" id="cb4-26" title="26">    <span class="kw">return</span> closerSum</a>
<a class="sourceLine" id="cb4-27" title="27">}</a>
<a class="sourceLine" id="cb4-28" title="28"></a>
<a class="sourceLine" id="cb4-29" title="29"><span class="co">//</span></a>
<a class="sourceLine" id="cb4-30" title="30"><span class="co">//  intAbs</span></a>
<a class="sourceLine" id="cb4-31" title="31"><span class="co">//  @Description: 取int绝对值</span></a>
<a class="sourceLine" id="cb4-32" title="32"><span class="co">//  @param num  参数</span></a>
<a class="sourceLine" id="cb4-33" title="33"><span class="co">//  @return int 取绝对值目标值</span></a>
<a class="sourceLine" id="cb4-34" title="34"><span class="co">//</span></a>
<a class="sourceLine" id="cb4-35" title="35"><span class="kw">func</span> intAbs(num <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb4-36" title="36">    <span class="kw">if</span> num &lt; <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb4-37" title="37">        <span class="kw">return</span> -num</a>
<a class="sourceLine" id="cb4-38" title="38">    }</a>
<a class="sourceLine" id="cb4-39" title="39">    <span class="kw">return</span> num</a>
<a class="sourceLine" id="cb4-40" title="40">}</a></code></pre></div>]]></description>
    <pubDate>Thu, 11 Aug 2022 11:35:16 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ [题目说明](https://leetcode.cn/problems/3sum/)]]></title>
    <link>https://scanas.ml/leetcode-doc/#/docs/array/0015.3sum</link>
    <guid isPermaLink="false">https://scanas.ml/leetcode-doc/#/docs/array/0015.3sum</guid>
    <description><![CDATA[<h2 id="题目说明"><a href="https://leetcode.cn/problems/3sum/">题目说明</a></h2>
<p>给你一个包含 n 个整数的数组nums，判断nums中是否存在三个元素 a，b，c ，使得a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：nums = []
输出：[]</code></pre>
<p>示例 3：</p>
<pre class="text"><code>输入：nums = [0]
输出：[]</code></pre>
<h2 id="解题思路">解题思路</h2>
<ol type="1">
<li>先进行排序（一开始自己写排序，写的冒号排序耗时比较久，标准库里写的快排，耗时-4ms），随后定义三个指针，两个循环下上层循环一个指针p ，下层循环左l 右r 两个指针。p指针始于最左侧，l = p + 1，r = len(nums)，下层循环，如果满足条件后分别对左右两指针进行向右向左查找（排过序），如果有相同则分别向右向左移动（此时还是已添加至三元组的值），最后再分别移动一位，保证下一次判断可以进行。检查完毕上层循环p指针加一，检查是否和前指针指向的值相等，相等则跳过此循环，p指针再加一，满足条件，继续下层循环，如此往复此题得解。拙见，感觉还是比较暴力。</li>
</ol>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">func</span> threeSum(nums []<span class="dt">int</span>) [][]<span class="dt">int</span> {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="co">//排序</span></a>
<a class="sourceLine" id="cb4-3" title="3">    sort.Ints(nums)</a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="kw">var</span> ret [][]<span class="dt">int</span></a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="kw">for</span> point := <span class="dv">0</span>; point &lt; <span class="bu">len</span>(nums)-<span class="dv">2</span>; point++ {</a>
<a class="sourceLine" id="cb4-6" title="6">        <span class="co">//排序后首位大于零则没有满足要求的三元组</span></a>
<a class="sourceLine" id="cb4-7" title="7">        <span class="kw">if</span> point == <span class="dv">0</span> &amp;&amp; nums[point] &gt; <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb4-8" title="8">            <span class="kw">break</span></a>
<a class="sourceLine" id="cb4-9" title="9">        }</a>
<a class="sourceLine" id="cb4-10" title="10">        <span class="co">//每次最左边数去重</span></a>
<a class="sourceLine" id="cb4-11" title="11">        <span class="kw">if</span> point &gt; <span class="dv">0</span> &amp;&amp; nums[point] == nums[point<span class="dv">-1</span>] {</a>
<a class="sourceLine" id="cb4-12" title="12">            <span class="kw">continue</span></a>
<a class="sourceLine" id="cb4-13" title="13">        }</a>
<a class="sourceLine" id="cb4-14" title="14">        left, right := point+<span class="dv">1</span>, <span class="bu">len</span>(nums)-<span class="dv">1</span></a>
<a class="sourceLine" id="cb4-15" title="15">        <span class="kw">for</span> left &lt; right {</a>
<a class="sourceLine" id="cb4-16" title="16">            sum := nums[point] + nums[left] + nums[right]</a>
<a class="sourceLine" id="cb4-17" title="17">            <span class="kw">if</span> sum == <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb4-18" title="18">                ret = <span class="bu">append</span>(ret, []<span class="dt">int</span>{nums[point], nums[left], nums[right]})</a>
<a class="sourceLine" id="cb4-19" title="19">                <span class="co">//针对左右指针得数进行去重，保证三元组每个组合唯一</span></a>
<a class="sourceLine" id="cb4-20" title="20">                <span class="kw">for</span> left &lt; right &amp;&amp; nums[left] == nums[left+<span class="dv">1</span>] {</a>
<a class="sourceLine" id="cb4-21" title="21">                    left++</a>
<a class="sourceLine" id="cb4-22" title="22">                }</a>
<a class="sourceLine" id="cb4-23" title="23">                <span class="kw">for</span> left &lt; right &amp;&amp; nums[right] == nums[right<span class="dv">-1</span>] {</a>
<a class="sourceLine" id="cb4-24" title="24">                    right--</a>
<a class="sourceLine" id="cb4-25" title="25">                }</a>
<a class="sourceLine" id="cb4-26" title="26">                left++</a>
<a class="sourceLine" id="cb4-27" title="27">                right--</a>
<a class="sourceLine" id="cb4-28" title="28">            } <span class="kw">else</span> <span class="kw">if</span> sum &gt; <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb4-29" title="29">                right--</a>
<a class="sourceLine" id="cb4-30" title="30">            } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb4-31" title="31">                left++</a>
<a class="sourceLine" id="cb4-32" title="32">            }</a>
<a class="sourceLine" id="cb4-33" title="33">        }</a>
<a class="sourceLine" id="cb4-34" title="34">    }</a>
<a class="sourceLine" id="cb4-35" title="35">    <span class="kw">return</span> ret</a>
<a class="sourceLine" id="cb4-36" title="36">}</a></code></pre></div>
<hr />
<h2 id="解题过程">解题过程</h2>
<ul>
<li>8月10日 错误，内存不足，我称之为灌肠思路，暴力解法，能拿到结果，首先三元组，长度小于三则直接返回空，然后对数组进行冒号排序，如果最小值都大于0那么肯定也没有返回空，随后进行双（三？）指针，取出符合要求的三元组，但是为了全部遍历完，这样就存在重复值，最后在做一遍去重，方法是将二维数组的第一层序列化为[]byte，转成string作为key存入map，根据map中key的唯一性，即可去除重复向，最后再将map的key转成数组存入二维数组中。思路应该没啥大问题，只是针对去重内存消耗过大</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb5-1" title="1"><span class="co">//小于三返回空</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">if</span> <span class="bu">len</span>(nums) &lt; <span class="dv">3</span> {</a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb5-4" title="4">}</a>
<a class="sourceLine" id="cb5-5" title="5"><span class="co">//排序</span></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="bu">len</span>(nums)-<span class="dv">1</span>; i++ {</a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="kw">for</span> j := <span class="dv">0</span>; j &lt; <span class="bu">len</span>(nums)-i<span class="dv">-1</span>; j++ {</a>
<a class="sourceLine" id="cb5-8" title="8">        <span class="kw">if</span> nums[j] &gt; nums[j+<span class="dv">1</span>] {</a>
<a class="sourceLine" id="cb5-9" title="9">            nums[j], nums[j+<span class="dv">1</span>] = nums[j+<span class="dv">1</span>], nums[j]</a>
<a class="sourceLine" id="cb5-10" title="10">        }</a>
<a class="sourceLine" id="cb5-11" title="11">    }</a>
<a class="sourceLine" id="cb5-12" title="12">}</a>
<a class="sourceLine" id="cb5-13" title="13">fmt.Println(nums)</a>
<a class="sourceLine" id="cb5-14" title="14"><span class="co">//最小大于0返回空</span></a>
<a class="sourceLine" id="cb5-15" title="15"><span class="kw">if</span> nums[<span class="dv">0</span>] &gt; <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb5-16" title="16">    <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb5-17" title="17">}</a>
<a class="sourceLine" id="cb5-18" title="18"><span class="co">//符合存入二维数组</span></a>
<a class="sourceLine" id="cb5-19" title="19"><span class="kw">var</span> ret [][]<span class="dt">int</span></a>
<a class="sourceLine" id="cb5-20" title="20">point, left, right := <span class="dv">0</span>, <span class="dv">1</span>, <span class="bu">len</span>(nums)-<span class="dv">1</span></a>
<a class="sourceLine" id="cb5-21" title="21"><span class="kw">for</span> point &lt; <span class="bu">len</span>(nums)-<span class="dv">2</span> {</a>
<a class="sourceLine" id="cb5-22" title="22">    <span class="kw">for</span> left &lt; right {</a>
<a class="sourceLine" id="cb5-23" title="23">        sum := nums[point] + nums[left] + nums[right]</a>
<a class="sourceLine" id="cb5-24" title="24">        <span class="kw">if</span> sum == <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb5-25" title="25">            ret = <span class="bu">append</span>(ret, []<span class="dt">int</span>{nums[point], nums[left], nums[right]})</a>
<a class="sourceLine" id="cb5-26" title="26">            left++</a>
<a class="sourceLine" id="cb5-27" title="27">        } <span class="kw">else</span> <span class="kw">if</span> sum &gt; <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb5-28" title="28">            right--</a>
<a class="sourceLine" id="cb5-29" title="29">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb5-30" title="30">            left++</a>
<a class="sourceLine" id="cb5-31" title="31">        }</a>
<a class="sourceLine" id="cb5-32" title="32">    }</a>
<a class="sourceLine" id="cb5-33" title="33">    point++</a>
<a class="sourceLine" id="cb5-34" title="34">    left = point + <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-35" title="35">    right = <span class="bu">len</span>(nums) - <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-36" title="36">}</a>
<a class="sourceLine" id="cb5-37" title="37"><span class="co">//上面得出结果有重复，需要去重，通过map去重</span></a>
<a class="sourceLine" id="cb5-38" title="38">m := <span class="bu">make</span>(<span class="kw">map</span>[<span class="dt">string</span>]<span class="kw">struct</span>{})</a>
<a class="sourceLine" id="cb5-39" title="39"><span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="bu">len</span>(ret); i++ {</a>
<a class="sourceLine" id="cb5-40" title="40">    marshal, _ := json.Marshal(ret[i])</a>
<a class="sourceLine" id="cb5-41" title="41">    <span class="co">// go 序列化后是 byte[]，需要转成 string</span></a>
<a class="sourceLine" id="cb5-42" title="42">    m[<span class="dt">string</span>(marshal)] = <span class="kw">struct</span>{}{}</a>
<a class="sourceLine" id="cb5-43" title="43">}</a>
<a class="sourceLine" id="cb5-44" title="44">ans := [][]<span class="dt">int</span>{}</a>
<a class="sourceLine" id="cb5-45" title="45"><span class="kw">for</span> key, _ := <span class="kw">range</span> m {</a>
<a class="sourceLine" id="cb5-46" title="46">    <span class="kw">var</span> item []<span class="dt">int</span></a>
<a class="sourceLine" id="cb5-47" title="47">    json.Unmarshal([]<span class="dt">byte</span>(key), &amp;item)</a>
<a class="sourceLine" id="cb5-48" title="48">    ans = <span class="bu">append</span>(ans, item)</a>
<a class="sourceLine" id="cb5-49" title="49">}</a>
<a class="sourceLine" id="cb5-50" title="50"><span class="kw">return</span> ans</a></code></pre></div>
<ul>
<li>优化暴力解法（排序+双指针）: 首先优化在开始存入的时候去除首位定位指针的重复值的情况，随后在符合条件(sum==0)的情况下，如果左右指针重复值则分别向右向左移动，到重复值的最后一个，最后再做left++ right–操作，保证下一循环判断进行，避免重复值重复添加三元组，也避免了更多内存消耗。 &gt; 执行用时： 28 ms, 在所有 Go 提交中击败了 90.31%的用户内存消耗：7.3 MB, 在所有 Go 提交中击败了 57.54%的用户</li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb6-1" title="1"><span class="co">//排序</span></a>
<a class="sourceLine" id="cb6-2" title="2">sort.Ints(nums) <span class="co">//使用标准库(底层使用快排)方法缩短时间</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="co">//符合存入二维数组</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="kw">var</span> ret [][]<span class="dt">int</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="kw">for</span> point := <span class="dv">0</span>; point &lt; <span class="bu">len</span>(nums)-<span class="dv">2</span>; point++ {</a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="kw">if</span> point == <span class="dv">0</span> &amp;&amp; nums[point] &gt; <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb6-7" title="7">        <span class="kw">break</span></a>
<a class="sourceLine" id="cb6-8" title="8">    }</a>
<a class="sourceLine" id="cb6-9" title="9">    <span class="kw">if</span> point &gt; <span class="dv">0</span> &amp;&amp; nums[point] == nums[point<span class="dv">-1</span>] {</a>
<a class="sourceLine" id="cb6-10" title="10">        <span class="kw">continue</span></a>
<a class="sourceLine" id="cb6-11" title="11">    }</a>
<a class="sourceLine" id="cb6-12" title="12">    left, right := point+<span class="dv">1</span>, <span class="bu">len</span>(nums)-<span class="dv">1</span></a>
<a class="sourceLine" id="cb6-13" title="13">    <span class="kw">for</span> left &lt; right {</a>
<a class="sourceLine" id="cb6-14" title="14">        sum := nums[point] + nums[left] + nums[right]</a>
<a class="sourceLine" id="cb6-15" title="15">        <span class="kw">if</span> sum == <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb6-16" title="16">            ret = <span class="bu">append</span>(ret, []<span class="dt">int</span>{nums[point], nums[left], nums[right]})</a>
<a class="sourceLine" id="cb6-17" title="17">            <span class="kw">for</span> left &lt; right &amp;&amp; nums[left] == nums[left+<span class="dv">1</span>] {</a>
<a class="sourceLine" id="cb6-18" title="18">                left++</a>
<a class="sourceLine" id="cb6-19" title="19">            }</a>
<a class="sourceLine" id="cb6-20" title="20">            <span class="kw">for</span> left &lt; right &amp;&amp; nums[right] == nums[right<span class="dv">-1</span>] {</a>
<a class="sourceLine" id="cb6-21" title="21">                right--</a>
<a class="sourceLine" id="cb6-22" title="22">            }</a>
<a class="sourceLine" id="cb6-23" title="23">            left++</a>
<a class="sourceLine" id="cb6-24" title="24">            right--</a>
<a class="sourceLine" id="cb6-25" title="25">        } <span class="kw">else</span> <span class="kw">if</span> sum &gt; <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb6-26" title="26">            right--</a>
<a class="sourceLine" id="cb6-27" title="27">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb6-28" title="28">            left++</a>
<a class="sourceLine" id="cb6-29" title="29">        }</a>
<a class="sourceLine" id="cb6-30" title="30">    }</a>
<a class="sourceLine" id="cb6-31" title="31">}</a>
<a class="sourceLine" id="cb6-32" title="32"><span class="kw">return</span> ret</a></code></pre></div>]]></description>
    <pubDate>Wed, 10 Aug 2022 13:51:40 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ [题目说明](https://leetcode.cn/problems/add-two-numbers/)]]></title>
    <link>https://scanas.ml/leetcode-doc/#/docs/linkedList/0002.add-two-numbers</link>
    <guid isPermaLink="false">https://scanas.ml/leetcode-doc/#/docs/linkedList/0002.add-two-numbers</guid>
    <description><![CDATA[<h2 id="题目说明"><a href="https://leetcode.cn/problems/add-two-numbers/">题目说明</a></h2>
<p>给你两个非空 的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0开头。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：l1 = [0], l2 = [0]
输出：[0]</code></pre>
<p>示例 3：</p>
<pre class="text"><code>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]</code></pre>
<p>每个链表中的节点数在范围 [1, 100] 内 0 &lt;= Node.val &lt;= 9 题目数据保证列表表示的数字不含前导零</p>
<h2 id="解题思路">解题思路</h2>
<p>O(n) 直接按照链表格式，先定义一个头节点，暂存值为0，每个链表取一个节点出来将Value与暂存值累加，然后取余数保存到自己定义链表的下一个节点的Value，取10的商保存为暂存值，随后将当前节点作为源节点的子节点，如此循环往复，直到两个链表为空和暂存值都为零时，则说明计算完成，返回头节点的下一个节点即可得到所求链表</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1">list := &amp;ListNode{<span class="dv">0</span>, <span class="ot">nil</span>}</a>
<a class="sourceLine" id="cb4-2" title="2">ret := list</a>
<a class="sourceLine" id="cb4-3" title="3">tmp := <span class="dv">0</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="kw">for</span> l1 != <span class="ot">nil</span> || l2 != <span class="ot">nil</span> || tmp != <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="kw">if</span> l1 != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb4-6" title="6">        tmp += l1.Val</a>
<a class="sourceLine" id="cb4-7" title="7">        l1 = l1.Next</a>
<a class="sourceLine" id="cb4-8" title="8">    }</a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="kw">if</span> l2 != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb4-10" title="10">        tmp += l2.Val</a>
<a class="sourceLine" id="cb4-11" title="11">        l2 = l2.Next</a>
<a class="sourceLine" id="cb4-12" title="12">    }</a>
<a class="sourceLine" id="cb4-13" title="13">    list.Next = &amp;ListNode{tmp % <span class="dv">10</span>, <span class="ot">nil</span>}</a>
<a class="sourceLine" id="cb4-14" title="14">    tmp = tmp / <span class="dv">10</span></a>
<a class="sourceLine" id="cb4-15" title="15">    list = list.Next</a>
<a class="sourceLine" id="cb4-16" title="16">}</a>
<a class="sourceLine" id="cb4-17" title="17"><span class="kw">return</span> ret.Next</a></code></pre></div>]]></description>
    <pubDate>Mon, 8 Aug 2022 22:35:17 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ [题目说明](https://leetcode.cn/problems/two-sum/)]]></title>
    <link>https://scanas.ml/leetcode-doc/#/docs/array/0001.two-sum</link>
    <guid isPermaLink="false">https://scanas.ml/leetcode-doc/#/docs/array/0001.two-sum</guid>
    <description><![CDATA[<h2 id="题目说明"><a href="https://leetcode.cn/problems/two-sum/">题目说明</a></h2>
<p>给定一个整数数组 nums和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：nums = [3,2,4], target = 6
输出：[1,2]</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：nums = [3,2,4], target = 6
输出：[1,2]</code></pre>
<p>示例 3：</p>
<pre class="text"><code>输入：nums = [3,3], target = 6
输出：[0,1]</code></pre>
<p>提示：</p>
<p>2 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？</p>
<h2 id="解题思路">解题思路</h2>
<ol type="1">
<li>(self) 开辟一个新空间存已经遍历过的值，后面的再去与前面的值进行比较，是否满足和为target，否则继续存，而因为map的时间复杂度为O(1)，所以比使用数组进行查询更好O(n)</li>
</ol>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">func</span> twoSum(nums []<span class="dt">int</span>, target <span class="dt">int</span>) []<span class="dt">int</span> {</a>
<a class="sourceLine" id="cb5-2" title="2">    ret := <span class="bu">make</span>(<span class="kw">map</span>[<span class="dt">int</span>]<span class="dt">int</span>)</a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="bu">len</span>(nums); i++ {</a>
<a class="sourceLine" id="cb5-4" title="4">        <span class="kw">if</span> key, ok := ret[target - nums[i]]; ok {</a>
<a class="sourceLine" id="cb5-5" title="5">            <span class="kw">return</span> []<span class="dt">int</span>{key, i}</a>
<a class="sourceLine" id="cb5-6" title="6">        }</a>
<a class="sourceLine" id="cb5-7" title="7">        ret[nums[i]] = i</a>
<a class="sourceLine" id="cb5-8" title="8">    }</a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb5-10" title="10">}</a></code></pre></div>]]></description>
    <pubDate>Sun, 7 Aug 2022 18:34:58 +0800</pubDate>
  </item>
  
</channel>
</rss>
