<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
<channel>
  <title>LeetCode刷题记录</title>
  <atom:link href="https://zggsong.github.io/leetcode-doc/feed.xml" rel="self" type="application/rss+xml" />
  <link>https://zggsong.github.io/leetcode-doc</link>
  <description>LeetCode刷题记录</description>
   
  <item>
    <title><![CDATA[ 设计链表]]></title>
    <link>https://zggsong.github.io/leetcode-doc/#/docs/linkedList/0707.design-linked-list</link>
    <guid isPermaLink="false">https://zggsong.github.io/leetcode-doc/#/docs/linkedList/0707.design-linked-list</guid>
    <description><![CDATA[<h2 id="设计链表">设计链表</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/design-linked-list/">https://leetcode.cn/problems/design-linked-list/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next是指向下一个节点的指针引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 O-index 的。</p>
<p>在链表类中实现这些功能：</p>
<p>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1</p>
<p>addAtHead(val)：在链表的第一个元素之前添加一个值为 val的节点。插入后，新节点将成为链表的第一个节点。</p>
<p>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</p>
<p>addAtindex (index，val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果 index 小于0，则在头部插入节点。</p>
<p>deleteAtindex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</p>
<p>示例：</p>
<pre class="text"><code>MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3
linkedList.get(1);            //返回2
linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3
linkedList.get(1);            //返回3</code></pre>
<h2 id="解题思路">解题思路</h2>]]></description>
    <pubDate>Thu, 2 Feb 2023 11:48:06 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[说明]]></title>
    <link>https://zggsong.github.io/leetcode-doc/#/README</link>
    <guid isPermaLink="false">https://zggsong.github.io/leetcode-doc/#/README</guid>
    <description><![CDATA[<h1 id="说明">说明</h1>
<p>LeetCode刷题记录 using Golang by <a href="https://zggsong.com">zggsong</a> with <a href="https://programmercarl.com/">代码随想录</a></p>
<p>blog <a href="https://www.zggsong.cn">zggsong.com</a></p>
<p>RSS <a href="https://zggsong.github.io/leetcode-doc/feed.xml">zggsong.github.io/leetcode-doc/feed.xml</a></p>]]></description>
    <pubDate>Wed, 1 Feb 2023 10:34:20 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[开始]]></title>
    <link>https://zggsong.github.io/leetcode-doc/#/_sidebar</link>
    <guid isPermaLink="false">https://zggsong.github.io/leetcode-doc/#/_sidebar</guid>
    <description><![CDATA[<ul>
<li>开始
<ul>
<li><a href="README.md">说明</a></li>
</ul></li>
<li>方法
<ul>
<li><a href="docs/methods/binary-search.md">二分查找</a></li>
<li><a href="docs/methods/double-pointer.md">双指针法</a></li>
</ul></li>
<li>数组
<ul>
<li><a href="docs/array/0001.two-sum.md">1. 两数之和 (简单)</a></li>
<li><a href="docs/array/0011.container-with-most-water.md">11. 盛最多水的容器 (中等)</a></li>
<li><a href="docs/array/0015.3sum.md">15. 三数之和 (中等)</a></li>
<li><a href="docs/array/0016.3sum-closest.md">16. 最接近的三数之和 (中等)</a></li>
<li><a href="docs/array/0018.4sum.md">18. 四数之和 (中等)</a></li>
<li><a href="docs/array/0026.remove-duplicates-from-sorted-array.md">26. 删除有序数组中的重复项 (简单)</a></li>
<li><a href="docs/array/0027.remove-element.md">27. 移除元素 (简单)</a></li>
<li><a href="docs/array/0031.next-permutation.md">31. 下一个排列 (中等)</a></li>
<li><a href="docs/array/0034.find-first-and-last-position-of-element-in-sorted-array.md">34. 在排序数组中查找元素的第一个和最后一个位置 (中等)</a></li>
<li><a href="docs/array/0054.spiral-matrix.md">54. 螺旋矩阵 (中等)</a></li>
<li><a href="docs/array/0059.spiral-matrix-ii.md">59. 螺旋矩阵II (中等)</a></li>
<li><a href="docs/array/0069.sqrtx.md">69. x的平方根 (简单)</a></li>
<li><a href="docs/array/0088.merge-sorted-array.md">88. 合并两个有序数组 (简单)</a></li>
<li><a href="docs/array/0118.pascals-triangle.md">118. 杨辉三角 (简单)</a></li>
<li><a href="docs/array/0119.pascals-triangle-ii.md">119. 杨辉三角 II (简单)</a></li>
<li><a href="docs/array/0121.best-time-to-buy-and-sell-stock.md">121. 买卖股票的最佳时机 (简单)</a></li>
<li><a href="docs/array/0136.single-number.md">136. 只出现一次的数字 (简单)</a></li>
<li><a href="docs/array/0209.minimum-size-subarray-sum.md">209. 长度最小的子数组 (中等)</a></li>
<li><a href="docs/array/0283.move-zeroes.md">283. 移动零 (简单)</a></li>
<li><a href="docs/array/704.binary-search.md">704. 二分查找 (简单)</a></li>
<li><a href="docs/array/0904.fruit-into-baskets.md">904. 水果成篮 (中等)</a></li>
<li><a href="docs/array/0977.squares-of-a-sorted-array.md">977. 有序数组的平方 (简单)</a></li>
<li><a href="docs/array/1403.minimum-subsequence-in-non-increasing-order.md">1403. 非递增顺序的最小子序列 (简单)</a></li>
</ul></li>
<li>字符串
<ul>
<li><a href="docs/string/0076.minimum-window-substring.md">76. 最小覆盖子串 (困难)</a></li>
<li><a href="docs/string/1408.string-matching-in-an-array.md">1408. 数组中的字符串匹配 (简单)</a></li>
<li><a href="docs/string/1417.reformat-the-string.md">1417. 重新格式化字符串 (简单)</a></li>
</ul></li>
<li>链表
<ul>
<li><a href="docs/linkedList/0002.add-two-numbers.md">2. 两数相加 (中等)</a></li>
<li><a href="docs/linkedList/0203.remove-linked-list-elements.md">203. 移除链表元素 (简单)</a></li>
<li><a href="docs/linkedList/0707.design-linked-list.md">707. 设计链表 (中等)</a></li>
</ul></li>
</ul>]]></description>
    <pubDate>Thu, 6 Oct 2022 21:51:16 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 移除链表元素]]></title>
    <link>https://zggsong.github.io/leetcode-doc/#/docs/linkedList/0203.remove-linked-list-elements</link>
    <guid isPermaLink="false">https://zggsong.github.io/leetcode-doc/#/docs/linkedList/0203.remove-linked-list-elements</guid>
    <description><![CDATA[<h2 id="移除链表元素">移除链表元素</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/remove-linked-list-elements/">https://leetcode.cn/problems/remove-linked-list-elements/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：head = [], val = 1
输出：[]</code></pre>
<h2 id="解题思路">解题思路</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">func</span> removeElements(head *ListNode, val <span class="dt">int</span>) *ListNode {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    <span class="kw">if</span> head == <span class="ot">nil</span> {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>        <span class="kw">return</span> head</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    }</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    newHead := &amp;ListNode{Val: <span class="dv">0</span>, Next: head}</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>    pre := newHead</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>    cur := head</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>    <span class="kw">for</span> cur != <span class="ot">nil</span> {</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>        <span class="kw">if</span> cur.Val == val {</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>            pre.Next = cur.Next</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>        } <span class="kw">else</span> {</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>            pre = cur</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>        }</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>        cur = cur.Next</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a>    }</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a>    <span class="kw">return</span> newHead.Next</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a>}</span></code></pre></div>]]></description>
    <pubDate>Fri, 30 Sep 2022 16:40:58 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 螺旋矩阵]]></title>
    <link>https://zggsong.github.io/leetcode-doc/#/docs/array/0054.spiral-matrix</link>
    <guid isPermaLink="false">https://zggsong.github.io/leetcode-doc/#/docs/array/0054.spiral-matrix</guid>
    <description><![CDATA[<h2 id="螺旋矩阵">螺旋矩阵</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/spiral-matrix/">https://leetcode.cn/problems/spiral-matrix/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]</code></pre>
<h2 id="解题思路">解题思路</h2>
<p><a href="https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
<p>本题解决思路继承自59.螺旋矩阵II，建议看完59.螺旋矩阵II之后再看本题</p>
<p>与59.螺旋矩阵II相同的是：两者都是模拟矩形的顺时针旋转，所以核心依然是依然是坚持循环不变量，按照左闭右开的原则</p>
<p>模拟顺时针画矩阵的过程:</p>
<p>填充上行从左到右 填充右列从上到下 填充下行从右到左 填充左列从下到上 由外向内一圈一圈这么画下去，如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/2020121623550681.png" /></p>
<p>这里每一种颜色，代表一条边，我们遍历的长度，可以看出每一个拐角处的处理规则，拐角处让给新的一条边来继续画。</p>
<p>与59.螺旋矩阵II不同的是：前题中的螺旋矩阵是正方形，只有正方形的边长n一个边界条件，而本题中，需要考虑长方形的长和宽(m行和n列)两个边界条件。自然，m可以等于n，即前题可视为本题在m==n的特殊情况。</p>
<p>我们从最一般的情况开始考虑，与59.螺旋矩阵II题解对比起来，m和n的带入，主要引来两方面的差异：</p>
<p>loop的计算： 本题的loop计算与59.螺旋矩阵II算法略微差异，因为存在rows和columns两个维度，可自行分析，loop只能取min(rows, columns)，例如rows = 5, columns = 7，那loop = 5 / 7 = 2 mid的计算及填充： 1、同样的原理，本题的mid计算也存在上述差异； 2、 如果min(rows, columns)为偶数，则不需要在最后单独考虑矩阵最中间位置的赋值 如果min(rows, columns)为奇数，则矩阵最中间位置不只是[mid][mid],而是会留下来一个特殊的中间行或者中间列，具体是中间行还是中间列，要看rows和columns的大小，如果rows &gt; columns,则是中间列，相反，则是中间行 代码如下，已经详细注释了每一步的目的，可以看出while循环里判断的情况是很多的，代码里处理的原则也是统一的左闭右开。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">func</span> spiralOrder(matrix [][]<span class="dt">int</span>) []<span class="dt">int</span> {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    <span class="kw">var</span> rows = <span class="bu">len</span>(matrix)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="kw">var</span> columns = <span class="bu">len</span>(matrix[<span class="dv">0</span>])</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    <span class="kw">if</span> <span class="bu">len</span>(matrix) == <span class="dv">0</span> || <span class="bu">len</span>(matrix[<span class="dv">0</span>]) == <span class="dv">0</span> {</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>        <span class="kw">return</span> []<span class="dt">int</span>{}</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>    }</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>    <span class="kw">var</span> ret []<span class="dt">int</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>    <span class="kw">var</span> startX, startY, i, j <span class="dt">int</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>    <span class="kw">var</span> loop, mid <span class="dt">int</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>    offset := <span class="dv">1</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>    <span class="kw">if</span> rows &gt; columns {</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>        loop = columns / <span class="dv">2</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>        mid = columns / <span class="dv">2</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>    } <span class="kw">else</span> {</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a>        loop = rows / <span class="dv">2</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a>        mid = rows / <span class="dv">2</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a>    }</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a>    <span class="kw">for</span> ; loop &gt; <span class="dv">0</span>; loop-- {</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a>        <span class="kw">for</span> j = startY; j &lt; startY+columns-offset; j++ {</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a>            ret = <span class="bu">append</span>(ret, matrix[startX][j])</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true"></a>        }</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true"></a>        <span class="kw">for</span> i = startX; i &lt; startX+rows-offset; i++ {</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true"></a>            ret = <span class="bu">append</span>(ret, matrix[i][j])</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true"></a>        }</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true"></a></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true"></a>        <span class="kw">for</span> ; j &gt; startY; j-- {</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true"></a>            ret = <span class="bu">append</span>(ret, matrix[i][j])</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true"></a>        }</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true"></a></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true"></a>        <span class="kw">for</span> ; i &gt; startX; i-- {</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true"></a>            ret = <span class="bu">append</span>(ret, matrix[i][j])</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true"></a>        }</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true"></a>        startX++</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true"></a>        startY++</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true"></a>        offset += <span class="dv">2</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true"></a>    }</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true"></a>    <span class="kw">if</span> <span class="dt">int</span>(math.Min(<span class="dt">float64</span>(rows), <span class="dt">float64</span>(columns)))%<span class="dv">2</span> == <span class="dv">1</span> {</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true"></a>        <span class="kw">if</span> rows &lt; columns {</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true"></a>            <span class="kw">for</span> i = mid; i &lt; mid+columns-rows+<span class="dv">1</span>; i++ {</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true"></a>                ret = <span class="bu">append</span>(ret, matrix[mid][i])</span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true"></a>            }</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true"></a>        } <span class="kw">else</span> {</span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true"></a>            <span class="kw">for</span> i = mid; i &lt; mid+rows-columns+<span class="dv">1</span>; i++ {</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true"></a>                ret = <span class="bu">append</span>(ret, matrix[i][mid])</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true"></a>            }</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true"></a>        }</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true"></a>    }</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true"></a>    <span class="kw">return</span> ret</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true"></a>}</span></code></pre></div>]]></description>
    <pubDate>Mon, 19 Sep 2022 20:48:24 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 螺旋矩阵II]]></title>
    <link>https://zggsong.github.io/leetcode-doc/#/docs/array/0059.spiral-matrix-ii</link>
    <guid isPermaLink="false">https://zggsong.github.io/leetcode-doc/#/docs/array/0059.spiral-matrix-ii</guid>
    <description><![CDATA[<h2 id="螺旋矩阵ii">螺旋矩阵II</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/spiral-matrix-ii/">https://leetcode.cn/problems/spiral-matrix-ii/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：n = 1
输出：[[1]]</code></pre>
<h2 id="解题思路">解题思路</h2>
<ul>
<li>没有算法，就是模拟过程。想象在一个坐标系中，每条边进行模拟，左开右闭，设置起始位置，偏移量之间的关系，随后遍历即可，注意边界值的处理，循环n/2次，最后注意奇数的中间多一个值，使用matrix[n/2][n/2]来填充</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">func</span> generateMatrix(n <span class="dt">int</span>) [][]<span class="dt">int</span> {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    <span class="co">//定义开始位置，每条边的始末位置，左闭右开的偏移量，填充count</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="kw">var</span> startX, startY, offset, count, i, j = <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    <span class="kw">var</span> matrix = <span class="bu">make</span>([][]<span class="dt">int</span>, n)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    <span class="kw">for</span> i = <span class="dv">0</span>; i &lt; n; i++ {</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>        matrix[i] = <span class="bu">make</span>([]<span class="dt">int</span>, n)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>    }</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>    <span class="kw">for</span> k := <span class="dv">0</span>; k &lt; n/<span class="dv">2</span>; k++ {</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>        <span class="co">//上</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>        <span class="kw">for</span> j = startY; j &lt; n-offset; j++ {</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>            matrix[startX][j] = count</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>            count++</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>        }</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>        <span class="co">//右</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a>        <span class="kw">for</span> i = startX; i &lt; n-offset; i++ {</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a>            matrix[i][j] = count</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a>            count++</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a>        }</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a>        <span class="co">//下</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a>        <span class="kw">for</span> ; j &gt; startY; j-- {</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true"></a>            matrix[i][j] = count</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true"></a>            count++</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true"></a>        }</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true"></a>        <span class="co">//左</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true"></a>        <span class="kw">for</span> ; i &gt; startX; i-- {</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true"></a>            matrix[i][j] = count</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true"></a>            count++</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true"></a>        }</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true"></a>        <span class="co">//每次循环过后，向内层进行遍历</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true"></a>        startX++</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true"></a>        startY++</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true"></a>        offset++</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true"></a>    }</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true"></a>    <span class="co">//如果n为奇数，中间则最后在填充一位</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true"></a>    <span class="kw">if</span> n%<span class="dv">2</span> == <span class="dv">1</span> {</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true"></a>        matrix[n/<span class="dv">2</span>][n/<span class="dv">2</span>] = count</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true"></a>    }</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true"></a>    <span class="kw">return</span> matrix</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true"></a>}</span></code></pre></div>]]></description>
    <pubDate>Sun, 18 Sep 2022 21:30:35 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 最小覆盖子串]]></title>
    <link>https://zggsong.github.io/leetcode-doc/#/docs/string/0076.minimum-window-substring</link>
    <guid isPermaLink="false">https://zggsong.github.io/leetcode-doc/#/docs/string/0076.minimum-window-substring</guid>
    <description><![CDATA[<h2 id="最小覆盖子串">最小覆盖子串</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/minimum-window-substring/">https://leetcode.cn/problems/minimum-window-substring/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。</p>
<p>注意： - 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 - 如果 s 中存在这样的子串，我们保证它是唯一的答案。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;
输出：&quot;BANC&quot;</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：s = &quot;a&quot;, t = &quot;a&quot;
输出：&quot;a&quot;</code></pre>
<p>示例3：</p>
<pre class="text"><code>输入: s = &quot;a&quot;, t = &quot;aa&quot;
输出: &quot;&quot;
解释: t 中两个字符 &#39;a&#39; 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。</code></pre>
<p>提示： 1 &lt;= s.length, t.length &lt;= 105 s 和 t 由英文字母组成</p>
<p>进阶：你能设计一个在 o(n) 时间内解决此问题的算法吗？</p>
<h2 id="解题思路">解题思路</h2>
<ul>
<li>首先要深刻理解题目意思才能处理好边界：<strong>s的子串中所有字符及数量都要大于等于t的字符以及数量</strong></li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">func</span> minWindow(s <span class="dt">string</span>, t <span class="dt">string</span>) <span class="dt">string</span> {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>    <span class="kw">var</span> sFreq, tFreq, ret = <span class="kw">map</span>[<span class="dt">byte</span>]<span class="dt">int</span>{}, <span class="kw">map</span>[<span class="dt">byte</span>]<span class="dt">int</span>{}, <span class="st">&quot;&quot;</span> <span class="co">//定义哈希来存储s,t中各字符数量以及默认返回值</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    <span class="kw">for</span> _, v := <span class="kw">range</span> t {                                      <span class="co">//存储t字符以及数量</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>        tFreq[<span class="dt">byte</span>(v)]++</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    }</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    <span class="co">//check := func(sFreq, tFreq map[byte]int) bool { //另一种写法</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>    <span class="co">//    for k, v := range tFreq {</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>    <span class="co">//    if sFreq[k] &lt; v {</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>    <span class="co">//        return false</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>    <span class="co">//    }</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>    <span class="co">//}</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>    <span class="co">//return true</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>    }</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>    <span class="kw">for</span> left, right := <span class="dv">0</span>, <span class="dv">0</span>; right &lt; <span class="bu">len</span>(s); right++ {</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>        sFreq[s[right]]++          <span class="co">//哈希存储s子串各字符以及数量</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>        <span class="kw">if</span> right-left+<span class="dv">1</span> &lt; <span class="bu">len</span>(t) { <span class="co">//长度比t还小则忽略的子串</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>            <span class="kw">continue</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>        }</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>        <span class="kw">for</span> check(sFreq, tFreq) { <span class="co">//判断子串个字符数量是否不小于t各字符数量</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>            <span class="kw">if</span> right-left+<span class="dv">1</span> &lt; <span class="bu">len</span>(ret) || ret == <span class="st">&quot;&quot;</span> {</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a>                ret = s[left : right+<span class="dv">1</span>] <span class="co">//当子串长度小于当前最小子串或者当前最小子串为默认值时，更新最小子串</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>            }</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a>            sFreq[s[left]]-- <span class="co">//子串最左侧字符数量减一</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a>            left++           <span class="co">//子串左指针右移</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>        }</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a>    }</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true"></a>    <span class="kw">return</span> ret</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true"></a>}</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true"></a></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true"></a><span class="kw">func</span> check(sFreq, tFreq <span class="kw">map</span>[<span class="dt">byte</span>]<span class="dt">int</span>) <span class="dt">bool</span> {</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true"></a>    <span class="kw">for</span> k, v := <span class="kw">range</span> tFreq {</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true"></a>        <span class="kw">if</span> sFreq[k] &lt; v {</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true"></a>            <span class="kw">return</span> <span class="ot">false</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true"></a>        }</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true"></a>    }</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true"></a>    <span class="kw">return</span> <span class="ot">true</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true"></a>}</span></code></pre></div>
<ul>
<li>TODO: slice写</li>
</ul>]]></description>
    <pubDate>Tue, 30 Aug 2022 19:23:17 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 水果成篮]]></title>
    <link>https://zggsong.github.io/leetcode-doc/#/docs/array/0904.fruit-into-baskets</link>
    <guid isPermaLink="false">https://zggsong.github.io/leetcode-doc/#/docs/array/0904.fruit-into-baskets</guid>
    <description><![CDATA[<h2 id="水果成篮">水果成篮</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/fruit-into-baskets/">https://leetcode.cn/problems/fruit-into-baskets/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p>
<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>
<p>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：fruits = [1,2,1]
输出：3
解释：可以采摘全部 3 棵树。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：fruits = [0,1,2,2]
输出：3
解释：可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</code></pre>
<p>示例3：</p>
<pre class="text"><code>输入：fruits = [1,2,3,2,2]
输出：4
解释：可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。</code></pre>
<p>示例4：</p>
<pre class="text"><code>输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：可以采摘 [1,2,1,1,2] 这五棵树。</code></pre>
<h2 id="解题思路">解题思路</h2>
<ul>
<li>解析题意：题目表达的是一个整数数组，按照一定的规则排列，从左往右读，只能读两种数字，每读完一次向右移，可以重复，一旦遇到第三个不同的数字，则立即停止读，最后得出只有两种数字的情况下最长的子数组的情况，并输出子数组长度</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">func</span> totalFruit(fruits []<span class="dt">int</span>) <span class="dt">int</span> {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    totalMap := <span class="bu">make</span>(<span class="kw">map</span>[<span class="dt">int</span>]<span class="dt">int</span>) <span class="co">//定义一个map存储符合条件的数</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    slowIndex, fastIndex := <span class="dv">0</span>, <span class="dv">0</span>  <span class="co">//定义双指针指针</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    ret := <span class="dv">0</span>                      <span class="co">//定义一个值来存储符合条件子数组的最大长度</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    <span class="kw">for</span> ; fastIndex &lt; <span class="bu">len</span>(fruits); fastIndex++ {</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>        totalMap[fruits[fastIndex]]++ <span class="co">//向map中存储数</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>        <span class="kw">for</span> <span class="bu">len</span>(totalMap) &gt; <span class="dv">2</span> {       <span class="co">//当map中key的数量超过两个则可以计算子数组</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>            tmp := fastIndex - slowIndex <span class="co">//计算当前符合条件子数组长度</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>            <span class="kw">if</span> tmp &gt; ret {               <span class="co">//如果当前长度大于之前的最大长度，则更新最大长度</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>                ret = tmp</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>            }</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>            totalMap[fruits[slowIndex]]--</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>            <span class="kw">if</span> totalMap[fruits[slowIndex]] == <span class="dv">0</span> { <span class="co">//当map fruits[slowIndex]的value减1后等于零则删除这个键</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>                <span class="bu">delete</span>(totalMap, fruits[slowIndex])</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a>            }</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a>            slowIndex++ <span class="co">//慢指针向后移动</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a>        }</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true"></a>    }</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true"></a>    tmp := fastIndex - slowIndex <span class="co">//快指针读完整个数组后再次判断快慢指针之间的长度是否大于最大长度</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true"></a>    <span class="kw">if</span> tmp &gt; ret {</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true"></a>        ret = tmp</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true"></a>    }</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true"></a>    <span class="kw">return</span> ret</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true"></a>}</span></code></pre></div>]]></description>
    <pubDate>Tue, 30 Aug 2022 10:41:41 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 长度最小的子数组]]></title>
    <link>https://zggsong.github.io/leetcode-doc/#/docs/array/0209.minimum-size-subarray-sum</link>
    <guid isPermaLink="false">https://zggsong.github.io/leetcode-doc/#/docs/array/0209.minimum-size-subarray-sum</guid>
    <description><![CDATA[<h2 id="长度最小的子数组">长度最小的子数组</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">https://leetcode.cn/problems/minimum-size-subarray-sum/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给定一个含有n个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组[numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：target = 4, nums = [1,4,4]
输出：1</code></pre>
<h2 id="解题思路">解题思路</h2>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" /></p>
<blockquote>
<p>上图来自<a href="https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">代码随想录</a></p>
</blockquote>
<ul>
<li>滑动窗口(双指针): 需要重复遍历数组，必然不能用O(n^2)的暴力解法，所以使用双指针法，思路主要根据上面动图展示，进行实现。双指针指向数组头，快指针右移，且子数组累加，直到子数组和大于等于target，则进入循环判断子数组和是否大于等于target，计算保存子数组长度是否小于当前result所存最小长度，满足则更新result，右移慢指针，且子数组减去原慢指针元素</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">func</span> minSubArrayLen(target <span class="dt">int</span>, nums []<span class="dt">int</span>) <span class="dt">int</span> {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>   i := <span class="dv">0</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>   l := <span class="bu">len</span>(nums)  <span class="co">// 数组长度</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>   sum := <span class="dv">0</span>        <span class="co">// 子数组之和</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>   result := l + <span class="dv">1</span> <span class="co">// 初始化返回长度为l+1，目的是为了判断“不存在符合条件的子数组，返回0”的情况</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>   <span class="kw">for</span> j := <span class="dv">0</span>; j &lt; l; j++ {</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>       sum += nums[j]</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>       <span class="kw">for</span> sum &gt;= target {</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>           subLength := j - i + <span class="dv">1</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>           <span class="kw">if</span> subLength &lt; result {</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>               result = subLength</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>           }</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>           sum -= nums[i]</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>           i++</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a>       }</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a>   }</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a>   <span class="kw">if</span> result == l+<span class="dv">1</span> {</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a>       <span class="kw">return</span> <span class="dv">0</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a>   } <span class="kw">else</span> {</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a>       <span class="kw">return</span> result</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true"></a>   }</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true"></a>}</span></code></pre></div>
<ul>
<li>自己写的滑动窗口，稍稍繁琐了点，主要在于针对满足条件情况下，可以使用for替代条件判断，避免忽略快指针固定且慢指针右移后的情况下有最优解，即第一种解法</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">func</span> minSubArrayLen(target <span class="dt">int</span>, nums []<span class="dt">int</span>) <span class="dt">int</span> {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>    <span class="kw">var</span> ret = math.MaxInt</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    i, j, sum := <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    flag := <span class="ot">true</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    <span class="co">//遍历数组</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    <span class="kw">for</span> j &lt; <span class="bu">len</span>(nums) {</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>        <span class="kw">if</span> flag {</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>            sum += nums[j]</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>        }</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>        <span class="kw">if</span> sum &gt;= target {</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>            tmp := j - i + <span class="dv">1</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>            <span class="kw">if</span> tmp &lt; ret {</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>                ret = tmp</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>            }</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>            sum -= nums[i]</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>            i++</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>            flag = <span class="ot">false</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>        } <span class="kw">else</span> {</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>            j++</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>            flag = <span class="ot">true</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a>        }</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>    }</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a>    <span class="co">//如果没有符合条件</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a>    <span class="kw">if</span> ret == math.MaxInt {</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>        ret = <span class="dv">0</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a>    }</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true"></a>    <span class="kw">return</span> ret</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true"></a>}</span></code></pre></div>]]></description>
    <pubDate>Fri, 26 Aug 2022 14:49:07 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 有序数组的平方]]></title>
    <link>https://zggsong.github.io/leetcode-doc/#/docs/array/0977.squares-of-a-sorted-array</link>
    <guid isPermaLink="false">https://zggsong.github.io/leetcode-doc/#/docs/array/0977.squares-of-a-sorted-array</guid>
    <description><![CDATA[<h2 id="有序数组的平方">有序数组的平方</h2>
<p>LeetCode: <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></p>
<h2 id="题目说明">题目说明</h2>
<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<p>示例 1：</p>
<pre class="text"><code>输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]</code></pre>
<p>示例 2：</p>
<pre class="text"><code>输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]</code></pre>
<h2 id="解题思路">解题思路</h2>
<ul>
<li>暴力解法：先平方后排序O(log(n))</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">func</span> sortedSquares(nums []<span class="dt">int</span>) []<span class="dt">int</span> {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    <span class="co">//先平方</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="kw">for</span> i, _ := <span class="kw">range</span> nums {</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>        nums[i] *= nums[i]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    }</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>    <span class="co">//冒号排序</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>    <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="bu">len</span>(nums)-<span class="dv">1</span>; i++ {</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>        <span class="kw">for</span> j := <span class="dv">0</span>; j &lt; <span class="bu">len</span>(nums)-i<span class="dv">-1</span>; j++ {</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>            <span class="kw">if</span> nums[j] &gt; nums[j+<span class="dv">1</span>] {</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>                nums[j], nums[j+<span class="dv">1</span>] = nums[j+<span class="dv">1</span>], nums[j]</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>            }</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>        }</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>    }</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>    <span class="kw">return</span> nums</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a>}</span></code></pre></div>
<ul>
<li>双指针法：由于是非递减序列，那就是两头大，中间小，双指针分别指向两端，比较指针元素平方后大小，大的添加至新数组尾部，相应的指针想中间移动，依次往前填充即可O(n)</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">func</span> sortedSquares(nums []<span class="dt">int</span>) []<span class="dt">int</span> {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>    <span class="kw">var</span> length = <span class="bu">len</span>(nums)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    <span class="kw">var</span> ret = <span class="bu">make</span>([]<span class="dt">int</span>, length)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    slowIndex, fastIndex, index := <span class="dv">0</span>, length<span class="dv">-1</span>, length<span class="dv">-1</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    <span class="kw">for</span> slowIndex &lt;= fastIndex {</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>        slowSquare, fastSquare := nums[slowIndex]*nums[slowIndex], nums[fastIndex]*nums[fastIndex]</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>        <span class="kw">if</span> slowSquare &gt; fastSquare {</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>            ret[index] = slowSquare</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>            slowIndex++</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>        } <span class="kw">else</span> {</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>            ret[index] = fastSquare</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>            fastIndex--</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>        }</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>        index--</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>    }</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>    <span class="kw">return</span> ret</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>}</span></code></pre></div>]]></description>
    <pubDate>Fri, 26 Aug 2022 11:11:38 +0800</pubDate>
  </item>
  
</channel>
</rss>
